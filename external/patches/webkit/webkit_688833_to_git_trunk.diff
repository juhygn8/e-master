diff -Naurp WebKit-r68833/JavaScriptCore/wtf/brew/RefPtrBrew.h wxwebkit/JavaScriptCore/wtf/brew/RefPtrBrew.h
--- WebKit-r68833/JavaScriptCore/wtf/brew/RefPtrBrew.h	2010-10-01 01:57:41.000000000 +0400
+++ wxwebkit/JavaScriptCore/wtf/brew/RefPtrBrew.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,53 +0,0 @@
-/*
- *  Copyright (C) 2005, 2006, 2007, 2008 Apple Inc. All rights reserved.
- *  Copyright (C) 2008 Collabora Ltd.
- *  Copyright (C) 2009 Martin Robinson
- *  Copyright (C) 2010 Company 100, Inc.
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Library General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Library General Public License for more details.
- *
- *  You should have received a copy of the GNU Library General Public License
- *  along with this library; see the file COPYING.LIB.  If not, write to
- *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- *  Boston, MA 02110-1301, USA.
- *
- */
-
-#ifndef RefPtrBrew_h
-#define RefPtrBrew_h
-
-#include "AlwaysInline.h"
-#include "PlatformRefPtr.h"
-#include <AEEIBase.h>
-#include <algorithm>
-
-namespace WTF {
-
-// All Brew MP classes are derived from either IBase or IQI.
-// Technically, IBase and IQI are different types. However, it is
-// okay to cast both types to IBase because they have AddRef and Release
-// in the same method vtable slots.
-template <typename T> inline T* refPlatformPtr(T* ptr)
-{
-    if (ptr)
-        IBase_AddRef(reinterpret_cast<IBase*>(ptr));
-    return ptr;
-}
-
-template <typename T> inline void derefPlatformPtr(T* ptr)
-{
-    if (ptr)
-        IBase_Release(reinterpret_cast<IBase*>(ptr));
-}
-
-} // namespace WTF
-
-#endif // RefPtrBrew_h
diff -Naurp WebKit-r68833/JavaScriptCore/wtf/brew/ShellBrew.h wxwebkit/JavaScriptCore/wtf/brew/ShellBrew.h
--- WebKit-r68833/JavaScriptCore/wtf/brew/ShellBrew.h	2010-10-01 01:57:41.000000000 +0400
+++ wxwebkit/JavaScriptCore/wtf/brew/ShellBrew.h	2010-10-23 03:50:46.375000070 +0400
@@ -34,7 +34,6 @@
 
 #include <wtf/Assertions.h>
 #include <wtf/PassOwnPtr.h>
-#include <wtf/PlatformRefPtr.h>
 
 namespace WTF {
 
@@ -50,21 +49,8 @@ static inline PassOwnPtr<T> createInstan
     return instance;
 }
 
-template <typename T>
-static inline PlatformRefPtr<T> createRefPtrInstance(AEECLSID cls)
-{
-    T* instance = 0;
-
-    IShell* shell = reinterpret_cast<AEEApplet*>(GETAPPINSTANCE())->m_pIShell;
-    ISHELL_CreateInstance(shell, cls, reinterpret_cast<void**>(&instance));
-    ASSERT(instance);
-
-    return adoptPlatformRef(instance);
-}
-
 } // namespace WTF
 
 using WTF::createInstance;
-using WTF::createRefPtrInstance;
 
 #endif // ShellBrew_h
diff -Naurp WebKit-r68833/JavaScriptCore/wtf/text/StringBuffer.h wxwebkit/JavaScriptCore/wtf/text/StringBuffer.h
--- WebKit-r68833/JavaScriptCore/wtf/text/StringBuffer.h	2010-10-01 01:57:41.000000000 +0400
+++ wxwebkit/JavaScriptCore/wtf/text/StringBuffer.h	2010-10-23 03:50:46.379000070 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2008, 2010 Apple Inc. All rights reserved.
+ * Copyright (C) 2008 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -32,7 +32,6 @@
 #include <wtf/Assertions.h>
 #include <wtf/Noncopyable.h>
 #include <wtf/unicode/Unicode.h>
-#include <limits>
 
 namespace WTF {
 
@@ -40,12 +39,9 @@ class StringBuffer : public Noncopyable 
 public:
     explicit StringBuffer(unsigned length)
         : m_length(length)
+        , m_data(static_cast<UChar*>(fastMalloc(length * sizeof(UChar))))
     {
-        if (m_length > std::numeric_limits<unsigned>::max() / sizeof(UChar))
-            CRASH();
-        m_data = static_cast<UChar*>(fastMalloc(m_length * sizeof(UChar)));
     }
-
     ~StringBuffer()
     {
         fastFree(m_data);
@@ -59,11 +55,8 @@ public:
 
     void resize(unsigned newLength)
     {
-        if (newLength > m_length) {
-            if (newLength > std::numeric_limits<unsigned>::max() / sizeof(UChar))
-                CRASH();
+        if (newLength > m_length)
             m_data = static_cast<UChar*>(fastRealloc(m_data, newLength * sizeof(UChar)));
-        }
         m_length = newLength;
     }
 
@@ -79,8 +72,8 @@ private:
     UChar* m_data;
 };
 
-} // namespace WTF
+}
 
 using WTF::StringBuffer;
 
-#endif // StringBuffer_h
+#endif
diff -Naurp WebKit-r68833/WebCore/css/CSSStyleSelector.cpp wxwebkit/WebCore/css/CSSStyleSelector.cpp
--- WebKit-r68833/WebCore/css/CSSStyleSelector.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/css/CSSStyleSelector.cpp	2010-10-23 03:51:25.603000069 +0400
@@ -3012,7 +3012,7 @@ void CSSStyleSelector::matchPageRulesFor
 bool CSSStyleSelector::isLeftPage(int pageIndex) const
 {
     bool isFirstPageLeft = false;
-    if (!m_rootElementStyle->isLeftToRightDirection())
+    if (m_rootElementStyle->direction() == RTL)
         isFirstPageLeft = true;
 
     return (pageIndex + (isFirstPageLeft ? 1 : 0)) % 2;
@@ -4190,9 +4190,9 @@ void CSSStyleSelector::applyProperty(int
             return;
         int id = primitiveValue->getIdent();
         if (id == CSSValueStart)
-            m_style->setTextAlign(m_style->isLeftToRightDirection() ? LEFT : RIGHT);
+            m_style->setTextAlign(m_style->direction() == LTR ? LEFT : RIGHT);
         else if (id == CSSValueEnd)
-            m_style->setTextAlign(m_style->isLeftToRightDirection() ? RIGHT : LEFT);
+            m_style->setTextAlign(m_style->direction() == LTR ? RIGHT : LEFT);
         else
             m_style->setTextAlign(*primitiveValue);
         return;
diff -Naurp WebKit-r68833/WebCore/editing/ApplyStyleCommand.cpp wxwebkit/WebCore/editing/ApplyStyleCommand.cpp
--- WebKit-r68833/WebCore/editing/ApplyStyleCommand.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/editing/ApplyStyleCommand.cpp	2010-10-23 03:51:25.708000070 +0400
@@ -1093,14 +1093,6 @@ void ApplyStyleCommand::fixRangeAndApply
     if (start == end && start.node()->hasTagName(brTag))
         pastEndNode = start.node()->traverseNextNode();
 
-    // Start from the highest fully selected ancestor so that we can modify the fully selected node.
-    // e.g. When applying font-size: large on <font color="blue">hello</font>, we need to include the font element in our run
-    // to generate <font color="blue" size="4">hello</font> instead of <font color="blue"><font size="4">hello</font></font>
-    RefPtr<Range> range = Range::create(startNode->document(), start, end);
-    Element* editableRoot = startNode->rootEditableElement();
-    while (editableRoot && startNode->parentNode() != editableRoot && isNodeVisiblyContainedWithin(startNode->parentNode(), range.get()))
-        startNode = startNode->parentNode();
-
     applyInlineStyleToNodeRange(style, startNode, pastEndNode);
 }
 
@@ -1171,21 +1163,7 @@ void ApplyStyleCommand::applyInlineStyle
 
 bool ApplyStyleCommand::removeStyleFromRunBeforeApplyingStyle(CSSMutableStyleDeclaration* style, Node*& runStart, Node*& runEnd)
 {
-    ASSERT(runStart && runEnd && runStart->parentNode() == runEnd->parentNode());
     Node* pastEndNode = runEnd->traverseNextSibling();
-    bool needToApplyStyle = false;
-    for (Node* node = runStart; node && node != pastEndNode; node = node->traverseNextNode()) {
-        if (node->childNodeCount())
-            continue;
-        if (getPropertiesNotIn(style, computedStyle(node).get())->length()
-            || (m_styledInlineElement && !enclosingNodeWithTag(positionBeforeNode(node), m_styledInlineElement->tagQName()))) {
-            needToApplyStyle = true;
-            break;
-        }
-    }
-    if (!needToApplyStyle)
-        return false;
-
     Node* next;
     for (Node* node = runStart; node && node != pastEndNode; node = next) {
         next = node->traverseNextNode();
@@ -1213,9 +1191,6 @@ bool ApplyStyleCommand::removeInlineStyl
     ASSERT(style);
     ASSERT(element);
 
-    if (!element->parentNode() || !element->parentNode()->isContentEditable())
-        return false;
-
     if (m_styledInlineElement && element->hasTagName(m_styledInlineElement->tagQName())) {
         if (mode != RemoveNone) {
             if (extractedStyle && element->inlineStyleDecl())
@@ -1675,7 +1650,7 @@ void ApplyStyleCommand::splitTextElement
 
 bool ApplyStyleCommand::shouldSplitTextElement(Element* element, CSSMutableStyleDeclaration* style)
 {
-    if (!element || !element->isHTMLElement())
+    if (!element || !element->isHTMLElement() || !element->parentElement() || !element->parentElement()->isContentEditable())
         return false;
 
     return shouldRemoveInlineStyleFromElement(style, static_cast<HTMLElement*>(element));
@@ -1860,57 +1835,26 @@ void ApplyStyleCommand::addBlockStyle(co
 
 void ApplyStyleCommand::addInlineStyleIfNeeded(CSSMutableStyleDeclaration *style, Node *startNode, Node *endNode, EAddStyledElement addStyledElement)
 {
-    // It's okay to obtain the style at the startNode because we've removed all relevant styles from the current run.
     StyleChange styleChange(style, Position(startNode, 0));
 
-    // Find appropriate font and span elements top-down.
-    HTMLElement* fontContainer = 0;
-    HTMLElement* styleContainer = 0;
-    for (Node* container = startNode; container && startNode == endNode; container = container->firstChild()) {
-        if (container->isHTMLElement() && container->hasTagName(fontTag))
-            fontContainer = static_cast<HTMLElement*>(container);
-        bool styleContainerIsNotSpan = !styleContainer || !styleContainer->hasTagName(spanTag);
-        if (container->isHTMLElement() && (container->hasTagName(spanTag) || (styleContainerIsNotSpan && container->childNodeCount())))
-            styleContainer = static_cast<HTMLElement*>(container);
-        if (!container->firstChild())
-            break;
-        startNode = container->firstChild();
-        endNode = container->lastChild();
-    }
-
     // Font tags need to go outside of CSS so that CSS font sizes override leagcy font sizes.
     if (styleChange.applyFontColor() || styleChange.applyFontFace() || styleChange.applyFontSize()) {
-        if (fontContainer) {
-            if (styleChange.applyFontColor())
-                setNodeAttribute(fontContainer, colorAttr, styleChange.fontColor());
-            if (styleChange.applyFontFace())
-                setNodeAttribute(fontContainer, faceAttr, styleChange.fontFace());
-            if (styleChange.applyFontSize())
-                setNodeAttribute(fontContainer, sizeAttr, styleChange.fontSize());
-        } else {
-            RefPtr<Element> fontElement = createFontElement(document());
-            if (styleChange.applyFontColor())
-                fontElement->setAttribute(colorAttr, styleChange.fontColor());
-            if (styleChange.applyFontFace())
-                fontElement->setAttribute(faceAttr, styleChange.fontFace());
-            if (styleChange.applyFontSize())
-                fontElement->setAttribute(sizeAttr, styleChange.fontSize());
-            surroundNodeRangeWithElement(startNode, endNode, fontElement.get());
-        }
+        RefPtr<Element> fontElement = createFontElement(document());
+
+        if (styleChange.applyFontColor())
+            fontElement->setAttribute(colorAttr, styleChange.fontColor());
+        if (styleChange.applyFontFace())
+            fontElement->setAttribute(faceAttr, styleChange.fontFace());
+        if (styleChange.applyFontSize())
+            fontElement->setAttribute(sizeAttr, styleChange.fontSize());
+
+        surroundNodeRangeWithElement(startNode, endNode, fontElement.get());
     }
 
     if (styleChange.cssStyle().length()) {
-        if (styleContainer) {
-            CSSMutableStyleDeclaration* existingStyle = static_cast<HTMLElement*>(styleContainer)->inlineStyleDecl();
-            if (existingStyle)
-                setNodeAttribute(styleContainer, styleAttr, existingStyle->cssText() + styleChange.cssStyle());
-            else
-                setNodeAttribute(styleContainer, styleAttr, styleChange.cssStyle());
-        } else {
-            RefPtr<Element> styleElement = createStyleSpanElement(document());
-            styleElement->setAttribute(styleAttr, styleChange.cssStyle());
-            surroundNodeRangeWithElement(startNode, endNode, styleElement.release());
-        }
+        RefPtr<Element> styleElement = createStyleSpanElement(document());
+        styleElement->setAttribute(styleAttr, styleChange.cssStyle());
+        surroundNodeRangeWithElement(startNode, endNode, styleElement.release());
     }
 
     if (styleChange.applyBold())
diff -Naurp WebKit-r68833/WebCore/editing/chromium/EditorChromium.cpp wxwebkit/WebCore/editing/chromium/EditorChromium.cpp
--- WebKit-r68833/WebCore/editing/chromium/EditorChromium.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/editing/chromium/EditorChromium.cpp	2010-10-23 03:51:25.722000070 +0400
@@ -39,7 +39,7 @@ namespace WebCore {
 
 PassRefPtr<Clipboard> Editor::newGeneralClipboard(ClipboardAccessPolicy policy, Frame* frame)
 {
-    return ClipboardChromium::create(Clipboard::CopyAndPaste, ChromiumDataObject::create(Clipboard::CopyAndPaste), policy, frame);
+    return ClipboardChromium::create(Clipboard::CopyAndPaste, ChromiumDataObject::create(), policy, frame);
 }
 
 } // namespace WebCore
diff -Naurp WebKit-r68833/WebCore/editing/Editor.cpp wxwebkit/WebCore/editing/Editor.cpp
--- WebKit-r68833/WebCore/editing/Editor.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/editing/Editor.cpp	2010-10-23 03:51:25.712000070 +0400
@@ -643,7 +643,7 @@ bool Editor::hasBidiSelection() const
         return false;
 
     RenderStyle* style = renderer->style();
-    if (!style->isLeftToRightDirection())
+    if (style->direction() == RTL)
         return true;
 
     return toRenderBlock(renderer)->containsNonZeroBidiLevel();
diff -Naurp WebKit-r68833/WebCore/editing/VisiblePosition.cpp wxwebkit/WebCore/editing/VisiblePosition.cpp
--- WebKit-r68833/WebCore/editing/VisiblePosition.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/editing/VisiblePosition.cpp	2010-10-23 03:51:25.721000070 +0400
@@ -123,9 +123,9 @@ Position VisiblePosition::leftVisuallyDi
 
         while (true) {
             if ((renderer->isReplaced() || renderer->isBR()) && offset == box->caretRightmostOffset())
-                return box->isLeftToRightDirection() ? previousVisuallyDistinctCandidate(m_deepPosition) : nextVisuallyDistinctCandidate(m_deepPosition);
+                return box->direction() == LTR ? previousVisuallyDistinctCandidate(m_deepPosition) : nextVisuallyDistinctCandidate(m_deepPosition);
 
-            offset = box->isLeftToRightDirection() ? renderer->previousOffset(offset) : renderer->nextOffset(offset);
+            offset = box->direction() == LTR ? renderer->previousOffset(offset) : renderer->nextOffset(offset);
 
             int caretMinOffset = box->caretMinOffset();
             int caretMaxOffset = box->caretMaxOffset();
@@ -133,7 +133,7 @@ Position VisiblePosition::leftVisuallyDi
             if (offset > caretMinOffset && offset < caretMaxOffset)
                 break;
 
-            if (box->isLeftToRightDirection() ? offset < caretMinOffset : offset > caretMaxOffset) {
+            if (box->direction() == LTR ? offset < caretMinOffset : offset > caretMaxOffset) {
                 // Overshot to the left.
                 InlineBox* prevBox = box->prevLeafChild();
                 if (!prevBox)
@@ -259,9 +259,9 @@ Position VisiblePosition::rightVisuallyD
 
         while (true) {
             if ((renderer->isReplaced() || renderer->isBR()) && offset == box->caretLeftmostOffset())
-                return box->isLeftToRightDirection() ? nextVisuallyDistinctCandidate(m_deepPosition) : previousVisuallyDistinctCandidate(m_deepPosition);
+                return box->direction() == LTR ? nextVisuallyDistinctCandidate(m_deepPosition) : previousVisuallyDistinctCandidate(m_deepPosition);
 
-            offset = box->isLeftToRightDirection() ? renderer->nextOffset(offset) : renderer->previousOffset(offset);
+            offset = box->direction() == LTR ? renderer->nextOffset(offset) : renderer->previousOffset(offset);
 
             int caretMinOffset = box->caretMinOffset();
             int caretMaxOffset = box->caretMaxOffset();
@@ -269,7 +269,7 @@ Position VisiblePosition::rightVisuallyD
             if (offset > caretMinOffset && offset < caretMaxOffset)
                 break;
 
-            if (box->isLeftToRightDirection() ? offset > caretMaxOffset : offset < caretMinOffset) {
+            if (box->direction() == LTR ? offset > caretMaxOffset : offset < caretMinOffset) {
                 // Overshot to the right.
                 InlineBox* nextBox = box->nextLeafChild();
                 if (!nextBox)
diff -Naurp WebKit-r68833/WebCore/html/canvas/CanvasRenderingContext2D.cpp wxwebkit/WebCore/html/canvas/CanvasRenderingContext2D.cpp
--- WebKit-r68833/WebCore/html/canvas/CanvasRenderingContext2D.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/html/canvas/CanvasRenderingContext2D.cpp	2010-10-23 03:51:25.794000071 +0400
@@ -1749,7 +1749,7 @@ void CanvasRenderingContext2D::drawTextI
     // FIXME: Need to turn off font smoothing.
 
     RenderStyle* computedStyle = canvas()->computedStyle();
-    bool rtl = computedStyle ? !computedStyle->isLeftToRightDirection() : false;
+    bool rtl = computedStyle ? computedStyle->direction() == RTL : false;
     bool override = computedStyle ? computedStyle->unicodeBidi() == Override : false;
 
     unsigned length = text.length();
diff -Naurp WebKit-r68833/WebCore/page/chromium/EventHandlerChromium.cpp wxwebkit/WebCore/page/chromium/EventHandlerChromium.cpp
--- WebKit-r68833/WebCore/page/chromium/EventHandlerChromium.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/page/chromium/EventHandlerChromium.cpp	2010-10-23 03:51:25.947000071 +0400
@@ -128,7 +128,7 @@ bool EventHandler::eventActivatedView(co
 
 PassRefPtr<Clipboard> EventHandler::createDraggingClipboard() const
 {
-    RefPtr<ChromiumDataObject> dataObject = ChromiumDataObject::create(Clipboard::DragAndDrop);
+    RefPtr<ChromiumDataObject> dataObject = ChromiumDataObject::create();
     return ClipboardChromium::create(Clipboard::DragAndDrop, dataObject.get(), ClipboardWritable, m_frame);
 }
 
diff -Naurp WebKit-r68833/WebCore/platform/chromium/ChromiumDataObject.cpp wxwebkit/WebCore/platform/chromium/ChromiumDataObject.cpp
--- WebKit-r68833/WebCore/platform/chromium/ChromiumDataObject.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/platform/chromium/ChromiumDataObject.cpp	2010-10-23 03:51:25.979000071 +0400
@@ -31,235 +31,56 @@
 #include "config.h"
 #include "ChromiumDataObject.h"
 
-#include "ChromiumBridge.h"
-#include "ClipboardMimeTypes.h"
-#include "Pasteboard.h"
-
 namespace WebCore {
 
-// Per RFC 2483, the line separator for "text/..." MIME types is CR-LF.
-static char const* const textMIMETypeLineSeparator = "\r\n";
-
-void ChromiumDataObject::clearData(const String& type)
-{
-    if (type == mimeTypeTextPlain) {
-        m_plainText = "";
-        return;
-    }
-
-    if (type == mimeTypeURL || type == mimeTypeTextURIList) {
-        m_uriList.clear();
-        m_url = KURL();
-        m_urlTitle = "";
-        return;
-    }
-
-    if (type == mimeTypeTextHTML) {
-        m_textHtml = "";
-        m_htmlBaseUrl = KURL();
-        return;
-    }
-
-    if (type == mimeTypeDownloadURL) {
-        m_downloadMetadata = "";
-        return;
-    }
-}
-
-void ChromiumDataObject::clearAll()
+void ChromiumDataObject::clear()
 {
     clearAllExceptFiles();
-    m_filenames.clear();
+    filenames.clear();
 }
 
 void ChromiumDataObject::clearAllExceptFiles()
 {
-    m_urlTitle = "";
-    m_url = KURL();
-    m_uriList.clear();
-    m_downloadMetadata = "";
-    m_fileExtension = "";
-    m_plainText = "";
-    m_textHtml = "";
-    m_htmlBaseUrl = KURL();
-    m_fileContentFilename = "";
-    if (m_fileContent)
-        m_fileContent->clear();
+    url = KURL();
+    urlTitle = "";
+    uriList.clear();
+    downloadMetadata = "";
+    fileExtension = "";
+    plainText = "";
+    textHtml = "";
+    htmlBaseUrl = KURL();
+    fileContentFilename = "";
+    if (fileContent)
+        fileContent->clear();
 }
 
 bool ChromiumDataObject::hasData() const
 {
-    return !m_url.isEmpty()
-        || !m_uriList.isEmpty()
-        || !m_downloadMetadata.isEmpty()
-        || !m_fileExtension.isEmpty()
-        || !m_filenames.isEmpty()
-        || !m_plainText.isEmpty()
-        || !m_textHtml.isEmpty()
-        || m_fileContent;
-}
-
-HashSet<String> ChromiumDataObject::types() const
-{
-    // This is currently broken for pasteboard events, and always has been.
-    HashSet<String> results;
-
-    if (!m_plainText.isEmpty()) {
-        results.add(mimeTypeText);
-        results.add(mimeTypeTextPlain);
-    }
-
-    if (!m_url.isEmpty()) {
-        results.add(mimeTypeURL);
-        results.add(mimeTypeTextURIList);
-    }
-
-    if (!m_textHtml.isEmpty())
-        results.add(mimeTypeTextHTML);
-
-    if (!m_filenames.isEmpty())
-        results.add("Files");
-
-    return results;
-}
-
-String ChromiumDataObject::getData(const String& type, bool& success)
-{
-    if (type == mimeTypeTextPlain) {
-        if (m_clipboardType == Clipboard::CopyAndPaste) {
-            PasteboardPrivate::ClipboardBuffer buffer =
-                Pasteboard::generalPasteboard()->isSelectionMode() ?
-                PasteboardPrivate::SelectionBuffer :
-                PasteboardPrivate::StandardBuffer;
-            String text = ChromiumBridge::clipboardReadPlainText(buffer);
-            success = !text.isEmpty();
-            return text;
-        }
-        success = !m_plainText.isEmpty();
-        return m_plainText;
-    }
-
-    if (type == mimeTypeURL) {
-        ASSERT(m_url.isEmpty() == m_uriList.isEmpty());
-        success = !m_url.isEmpty();
-        return m_url.string();
-    }
-
-    if (type == mimeTypeTextURIList) {
-        ASSERT(m_url.isEmpty() == m_uriList.isEmpty());
-        if (m_uriList.isEmpty()) {
-            success = false;
-            return "";
-        }
-        String uriListString(m_uriList[0]);
-        for (size_t i = 1; i < m_uriList.size(); i++) {
-            uriListString.append(textMIMETypeLineSeparator);
-            uriListString.append(m_uriList[i]);
-        }
-        success = true;
-        return uriListString;
-    }
-
-    if (type == mimeTypeTextHTML) {
-        if (m_clipboardType == Clipboard::CopyAndPaste) {
-            PasteboardPrivate::ClipboardBuffer buffer =
-                Pasteboard::generalPasteboard()->isSelectionMode() ?
-                PasteboardPrivate::SelectionBuffer :
-                PasteboardPrivate::StandardBuffer;
-            String htmlText;
-            KURL sourceURL;
-            ChromiumBridge::clipboardReadHTML(buffer, &htmlText, &sourceURL);
-            success = !htmlText.isEmpty();
-            return htmlText;
-        }
-        success = !m_textHtml.isEmpty();
-        return m_textHtml;
-    }
-
-    if (type == mimeTypeDownloadURL) {
-        success = !m_downloadMetadata.isEmpty();
-        return m_downloadMetadata;
-    }
-
-    success = false;
-    return String();
-}
-
-bool ChromiumDataObject::setData(const String& type, const String& data)
-{
-    if (type == mimeTypeTextPlain) {
-        m_plainText = data;
-        return true;
-    }
-
-    if (type == mimeTypeURL || type == mimeTypeTextURIList) {
-        m_url = KURL();
-        // Line separator is \r\n per RFC 2483 - however, for compatibility reasons
-        // we also allow just \n here.
-        data.split('\n', m_uriList);
-        // Strip white space on all lines, including trailing \r from above split.
-        // If this leaves a line empty, remove it completely.
-        //
-        // Also, copy the first valid URL into the 'url' member as well.
-        // In case no entry is a valid URL (i.e., remarks only), then we leave 'url' empty.
-        // I.e., in that case subsequent calls to getData("URL") will get an empty string.
-        // This is in line with the HTML5 spec (see "The DragEvent and DataTransfer interfaces").
-        for (size_t i = 0; i < m_uriList.size(); /**/) {
-            String& line = m_uriList[i];
-            line = line.stripWhiteSpace();
-            if (line.isEmpty()) {
-                m_uriList.remove(i);
-                continue;
-            }
-            ++i;
-            // Only copy the first valid URL.
-            if (m_url.isValid())
-                continue;
-            if (line[0] == '#')
-                continue;
-            KURL url = KURL(ParsedURLString, line);
-            if (url.isValid())
-                m_url = url;
-        }
-        ASSERT(m_url.isEmpty() == m_uriList.isEmpty());
-        return true;
-    }
-
-    if (type == mimeTypeTextHTML) {
-        m_textHtml = data;
-        m_htmlBaseUrl = KURL();
-        return true;
-    }
-
-    if (type == mimeTypeDownloadURL) {
-        m_downloadMetadata = data;
-        return true;
-    }
-
-    return false;
-}
-
-ChromiumDataObject::ChromiumDataObject(Clipboard::ClipboardType clipboardType)
-    : m_clipboardType(clipboardType)
-{
+    return !url.isEmpty()
+        || !uriList.isEmpty()
+        || !downloadMetadata.isEmpty()
+        || !fileExtension.isEmpty()
+        || !filenames.isEmpty()
+        || !plainText.isEmpty()
+        || !textHtml.isEmpty()
+        || fileContent;
 }
 
 ChromiumDataObject::ChromiumDataObject(const ChromiumDataObject& other)
     : RefCounted<ChromiumDataObject>()
-    , m_clipboardType(other.m_clipboardType)
-    , m_urlTitle(other.m_urlTitle)
-    , m_downloadMetadata(other.m_downloadMetadata)
-    , m_fileExtension(other.m_fileExtension)
-    , m_filenames(other.m_filenames)
-    , m_plainText(other.m_plainText)
-    , m_textHtml(other.m_textHtml)
-    , m_htmlBaseUrl(other.m_htmlBaseUrl)
-    , m_fileContentFilename(other.m_fileContentFilename)
-    , m_url(other.m_url)
-    , m_uriList(other.m_uriList)
+    , urlTitle(other.urlTitle)
+    , downloadMetadata(other.downloadMetadata)
+    , fileExtension(other.fileExtension)
+    , filenames(other.filenames)
+    , plainText(other.plainText)
+    , textHtml(other.textHtml)
+    , htmlBaseUrl(other.htmlBaseUrl)
+    , fileContentFilename(other.fileContentFilename)
+    , url(other.url)
+    , uriList(other.uriList)
 {
-    if (other.m_fileContent.get())
-        m_fileContent = other.m_fileContent->copy();
+    if (other.fileContent.get())
+        fileContent = other.fileContent->copy();
 }
 
 } // namespace WebCore
diff -Naurp WebKit-r68833/WebCore/platform/chromium/ChromiumDataObject.h wxwebkit/WebCore/platform/chromium/ChromiumDataObject.h
--- WebKit-r68833/WebCore/platform/chromium/ChromiumDataObject.h	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/platform/chromium/ChromiumDataObject.h	2010-10-23 03:51:25.979000071 +0400
@@ -31,14 +31,11 @@
 #ifndef ChromiumDataObject_h
 #define ChromiumDataObject_h
 
-#include "Clipboard.h"
 #include "KURL.h"
 #include "PlatformString.h"
 #include "SharedBuffer.h"
-#include <wtf/HashSet.h>
 #include <wtf/RefPtr.h>
 #include <wtf/Vector.h>
-#include <wtf/text/StringHash.h>
 
 namespace WebCore {
 
@@ -47,9 +44,9 @@ namespace WebCore {
     // of and is not specific to a platform.
     class ChromiumDataObject : public RefCounted<ChromiumDataObject> {
     public:
-        static PassRefPtr<ChromiumDataObject> create(Clipboard::ClipboardType clipboardType)
+        static PassRefPtr<ChromiumDataObject> create()
         {
-            return adoptRef(new ChromiumDataObject(clipboardType));
+            return adoptRef(new ChromiumDataObject);
         }
 
         PassRefPtr<ChromiumDataObject> copy() const
@@ -57,61 +54,60 @@ namespace WebCore {
             return adoptRef(new ChromiumDataObject(*this));
         }
 
-        void clearData(const String& type);
-        void clearAll();
+        void clear();
         void clearAllExceptFiles();
-
         bool hasData() const;
 
-        HashSet<String> types() const;
-        String getData(const String& type, bool& success);
-        bool setData(const String& type, const String& data);
-
-        // Special handlers for URL/HTML metadata.
-        String urlTitle() const { return m_urlTitle; }
-        void setUrlTitle(const String& urlTitle) { m_urlTitle = urlTitle; }
-        KURL htmlBaseUrl() const { return m_htmlBaseUrl; }
-        void setHtmlBaseUrl(const KURL& url) { m_htmlBaseUrl = url; }
-
-        // Used to handle files being dragged in.
-        bool containsFilenames() const { return !m_filenames.isEmpty(); }
-        Vector<String> filenames() const { return m_filenames; }
-        void setFilenames(const Vector<String>& filenames) { m_filenames = filenames; }
-
-        // Used to handle files (images) being dragged out.
-        String fileExtension() const { return m_fileExtension; }
-        void setFileExtension(const String& fileExtension) { m_fileExtension = fileExtension; }
-        String fileContentFilename() const { return m_fileContentFilename; }
-        void setFileContentFilename(const String& fileContentFilename) { m_fileContentFilename = fileContentFilename; }
-        PassRefPtr<SharedBuffer> fileContent() const { return m_fileContent; }
-        void setFileContent(PassRefPtr<SharedBuffer> fileContent) { m_fileContent = fileContent; }
+        void clearURL()
+        {
+            url = KURL();
+            uriList.clear();
+            urlTitle = "";
+        }
 
-    private:
-        ChromiumDataObject(Clipboard::ClipboardType);
-        ChromiumDataObject(const ChromiumDataObject&);
+        bool hasValidURL() const
+        {
+            return url.isValid();
+        }
+
+        KURL getURL() const
+        {
+            return url;
+        }
+
+        void setURL(const KURL& newURL)
+        {
+            url = newURL;
+            uriList.clear();
+            if (newURL.isEmpty())
+                return;
+            uriList.append(newURL.string());
+        }
+
+        String urlTitle;
 
-        Clipboard::ClipboardType m_clipboardType;
+        String downloadMetadata;
 
-        String m_urlTitle;
+        String fileExtension;
+        Vector<String> filenames;
 
-        String m_downloadMetadata;
+        String plainText;
 
-        String m_fileExtension;
-        Vector<String> m_filenames;
+        String textHtml;
+        KURL htmlBaseUrl;
 
-        String m_plainText;
+        String fileContentFilename;
+        RefPtr<SharedBuffer> fileContent;
 
-        String m_textHtml;
-        KURL m_htmlBaseUrl;
+    private:
+        // URL and uri-list are linked, so they should not be accessed individually.
+        KURL url;
+        Vector<String> uriList;
 
-        String m_fileContentFilename;
-        RefPtr<SharedBuffer> m_fileContent;
+        ChromiumDataObject() {}
+        ChromiumDataObject(const ChromiumDataObject&);
 
-        // These two are linked. Setting m_url will set m_uriList to the same
-        // string value; setting m_uriList will cause its contents to be parsed
-        // according to RFC 2483 and the first URL found will be set in m_url.
-        KURL m_url;
-        Vector<String> m_uriList;
+        friend class ClipboardChromium;
     };
 
 } // namespace WebCore
diff -Naurp WebKit-r68833/WebCore/platform/chromium/ClipboardChromium.cpp wxwebkit/WebCore/platform/chromium/ClipboardChromium.cpp
--- WebKit-r68833/WebCore/platform/chromium/ClipboardChromium.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/platform/chromium/ClipboardChromium.cpp	2010-10-23 03:51:25.979000071 +0400
@@ -28,8 +28,8 @@
 #include "ClipboardChromium.h"
 
 #include "CachedImage.h"
+#include "ChromiumBridge.h"
 #include "ChromiumDataObject.h"
-#include "ClipboardMimeTypes.h"
 #include "ClipboardUtilitiesChromium.h"
 #include "Document.h"
 #include "DragData.h"
@@ -40,6 +40,7 @@
 #include "Image.h"
 #include "MIMETypeRegistry.h"
 #include "NamedNodeMap.h"
+#include "Pasteboard.h"
 #include "PlatformString.h"
 #include "Range.h"
 #include "RenderImage.h"
@@ -54,12 +55,40 @@ using namespace HTMLNames;
 // We provide the IE clipboard types (URL and Text), and the clipboard types specified in the WHATWG Web Applications 1.0 draft
 // see http://www.whatwg.org/specs/web-apps/current-work/ Section 6.3.5.3
 
-static String normalizeType(const String& type)
+enum ClipboardDataType {
+    ClipboardDataTypeNone,
+
+    ClipboardDataTypeURL,
+    ClipboardDataTypeURIList,
+    ClipboardDataTypeDownloadURL,
+    ClipboardDataTypePlainText,
+    ClipboardDataTypeHTML,
+
+    ClipboardDataTypeOther,
+};
+
+// Per RFC 2483, the line separator for "text/..." MIME types is CR-LF.
+static char const* const textMIMETypeLineSeparator = "\r\n";
+
+static ClipboardDataType clipboardTypeFromMIMEType(const String& type)
 {
     String cleanType = type.stripWhiteSpace().lower();
-    if (cleanType == mimeTypeText || cleanType.startsWith(mimeTypeTextPlainEtc))
-        return mimeTypeTextPlain;
-    return cleanType;
+    if (cleanType.isEmpty())
+        return ClipboardDataTypeNone;
+
+    // Includes two special cases for IE compatibility.
+    if (cleanType == "text" || cleanType == "text/plain" || cleanType.startsWith("text/plain;"))
+        return ClipboardDataTypePlainText;
+    if (cleanType == "url")
+        return ClipboardDataTypeURL;
+    if (cleanType == "text/uri-list")
+        return ClipboardDataTypeURIList;
+    if (cleanType == "downloadurl")
+        return ClipboardDataTypeDownloadURL;
+    if (cleanType == "text/html")
+        return ClipboardDataTypeHTML;
+
+    return ClipboardDataTypeOther;
 }
 
 PassRefPtr<Clipboard> Clipboard::create(ClipboardAccessPolicy policy, DragData* dragData, Frame* frame)
@@ -88,7 +117,36 @@ void ClipboardChromium::clearData(const 
     if (policy() != ClipboardWritable || !m_dataObject)
         return;
 
-    m_dataObject->clearData(normalizeType(type));
+    ClipboardDataType dataType = clipboardTypeFromMIMEType(type);
+    switch (dataType) {
+    case ClipboardDataTypeNone:
+        // If called with no arguments, everything except the file list must be cleared.
+        // (See HTML5 spec, "The DragEvent and DataTransfer interfaces")
+        m_dataObject->clearAllExceptFiles();
+        return;
+
+    case ClipboardDataTypeURL:
+    case ClipboardDataTypeURIList:
+        m_dataObject->clearURL();
+        return;
+
+    case ClipboardDataTypeDownloadURL:
+        m_dataObject->downloadMetadata = "";
+        return;
+        
+    case ClipboardDataTypePlainText:
+        m_dataObject->plainText = "";
+        return;
+
+    case ClipboardDataTypeHTML:
+        m_dataObject->textHtml = "";
+        m_dataObject->htmlBaseUrl = KURL();
+        return;
+
+    case ClipboardDataTypeOther:
+        // Not yet implemented, see https://bugs.webkit.org/show_bug.cgi?id=34410
+        return;
+    }
 
     ASSERT_NOT_REACHED();
 }
@@ -98,7 +156,7 @@ void ClipboardChromium::clearAllData()
     if (policy() != ClipboardWritable)
         return;
 
-    m_dataObject->clearAll();
+    m_dataObject->clear();
 }
 
 String ClipboardChromium::getData(const String& type, bool& success) const
@@ -107,7 +165,80 @@ String ClipboardChromium::getData(const 
     if (policy() != ClipboardReadable || !m_dataObject)
         return String();
 
-    return m_dataObject->getData(normalizeType(type), success);
+    ClipboardDataType dataType = clipboardTypeFromMIMEType(type);
+    switch (dataType) {
+    case ClipboardDataTypeNone:
+        return String();
+
+    // Hack for URLs. file URLs are used internally for drop's default action, but we don't want
+    // to expose them to the page, so we filter them out here.
+    case ClipboardDataTypeURIList:
+        {
+            String text;
+            for (size_t i = 0; i < m_dataObject->uriList.size(); ++i) {
+                const String& uri = m_dataObject->uriList[i];
+                if (protocolIs(uri, "file"))
+                    continue;
+                ASSERT(!uri.isEmpty());
+                if (!text.isEmpty())
+                    text.append(textMIMETypeLineSeparator);
+                // URIs have already been canonicalized, so copy everything verbatim.
+                text.append(uri);
+            }
+            success = !text.isEmpty();
+            return text;
+        }
+
+    case ClipboardDataTypeURL:
+        // In case of a previous setData('text/uri-list'), setData() has already
+        // prepared the 'url' member, so we can just retrieve it here.
+        if (!m_dataObject->url.isEmpty() && !m_dataObject->url.isLocalFile()) {
+            success = true;
+            return m_dataObject->url.string();
+        }
+        return String();
+
+    case ClipboardDataTypeDownloadURL:
+        success = !m_dataObject->downloadMetadata.isEmpty();
+        return m_dataObject->downloadMetadata;
+    
+    case ClipboardDataTypePlainText:
+        if (isForCopyAndPaste()) {
+            PasteboardPrivate::ClipboardBuffer buffer = 
+                Pasteboard::generalPasteboard()->isSelectionMode() ?
+                PasteboardPrivate::SelectionBuffer : 
+                PasteboardPrivate::StandardBuffer;
+            String text = ChromiumBridge::clipboardReadPlainText(buffer);
+            success = !text.isEmpty();
+            return text;
+        }
+        // Otherwise return whatever is stored in plainText.
+        success = !m_dataObject->plainText.isEmpty();
+        return m_dataObject->plainText;
+
+    case ClipboardDataTypeHTML:
+        if (isForCopyAndPaste()) {
+            PasteboardPrivate::ClipboardBuffer buffer = 
+                Pasteboard::generalPasteboard()->isSelectionMode() ?
+                PasteboardPrivate::SelectionBuffer : 
+                PasteboardPrivate::StandardBuffer;
+            String htmlText;
+            KURL sourceURL;
+            ChromiumBridge::clipboardReadHTML(buffer, &htmlText, &sourceURL);
+            success = !htmlText.isEmpty();
+            return htmlText;
+        }
+        // Otherwise return whatever is stored in textHtml.
+        success = !m_dataObject->textHtml.isEmpty();
+        return m_dataObject->textHtml;
+
+    case ClipboardDataTypeOther:
+        // not yet implemented, see https://bugs.webkit.org/show_bug.cgi?id=34410
+        return String();
+    }
+
+    ASSERT_NOT_REACHED();
+    return String();
 }
 
 bool ClipboardChromium::setData(const String& type, const String& data)
@@ -115,7 +246,69 @@ bool ClipboardChromium::setData(const St
     if (policy() != ClipboardWritable)
         return false;
 
-    return m_dataObject->setData(normalizeType(type), data);
+    ClipboardDataType dataType = clipboardTypeFromMIMEType(type);
+    switch (dataType) {
+    case ClipboardDataTypeNone:
+        return false;
+
+    case ClipboardDataTypeURL:
+        // For setData(), "URL" must be treated as "text/uri-list".
+        // (See HTML5 spec, "The DragEvent and DataTransfer interfaces")
+    case ClipboardDataTypeURIList:
+        m_dataObject->url = KURL();
+        // Line separator is \r\n per RFC 2483 - however, for compatibility reasons
+        // we also allow just \n here. 
+        data.split('\n', m_dataObject->uriList);
+        // Strip white space on all lines, including trailing \r from above split.
+        // If this leaves a line empty, remove it completely.
+        //
+        // Also, copy the first valid URL into the 'url' member as well.
+        // In case no entry is a valid URL (i.e., remarks only), then we leave 'url' empty.
+        // I.e., in that case subsequent calls to getData("URL") will get an empty string.
+        // This is in line with the HTML5 spec (see "The DragEvent and DataTransfer interfaces").
+        for (size_t i = 0; i < m_dataObject->uriList.size(); /**/) {
+            String& line = m_dataObject->uriList[i];
+            line = line.stripWhiteSpace();
+            if (line.isEmpty()) {
+                m_dataObject->uriList.remove(i);
+                continue;
+            }
+            ++i;
+            // Only copy the first valid URL.
+            if (m_dataObject->url.isValid())
+                continue;
+            // Skip remarks.
+            if (line[0] == '#')
+                continue;
+            KURL url = KURL(ParsedURLString, line);
+            if (url.isValid())
+                m_dataObject->url = url;
+        }
+        if (m_dataObject->uriList.isEmpty()) {
+            ASSERT(m_dataObject->url.isEmpty());
+            return data.isEmpty();
+        }
+        return true;
+
+    case ClipboardDataTypeDownloadURL:
+        m_dataObject->downloadMetadata = data;
+        return true;
+
+    case ClipboardDataTypePlainText:
+        m_dataObject->plainText = data;
+        return true;
+
+    case ClipboardDataTypeHTML:
+        m_dataObject->textHtml = data;
+        return true;
+
+    case ClipboardDataTypeOther:
+        // Not yet implemented, see https://bugs.webkit.org/show_bug.cgi?id=34410
+        return false;
+    }
+    
+    ASSERT_NOT_REACHED();
+    return false;
 }
 
 // extensions beyond IE's API
@@ -128,7 +321,33 @@ HashSet<String> ClipboardChromium::types
     if (!m_dataObject)
         return results;
 
-    results = m_dataObject->types();
+    if (!m_dataObject->filenames.isEmpty())
+        results.add("Files");
+
+    // Hack for URLs. file URLs are used internally for drop's default action, but we don't want
+    // to expose them to the page, so we filter them out here.
+    if (m_dataObject->url.isValid() && !m_dataObject->url.isLocalFile()) {
+        ASSERT(!m_dataObject->uriList.isEmpty());
+        results.add("URL");
+    }
+
+    if (!m_dataObject->uriList.isEmpty()) {
+        // Verify that the URI list contains at least one non-file URL.
+        for (Vector<String>::const_iterator it = m_dataObject->uriList.begin();
+             it != m_dataObject->uriList.end(); ++it) {
+            if (!protocolIs(*it, "file")) {
+                // Note that even if the URI list is not empty, it may not actually
+                // contain a valid URL, so we can't return "URL" here.
+                results.add("text/uri-list");
+                break;
+            }
+        }
+    }
+
+    if (!m_dataObject->plainText.isEmpty()) {
+        results.add("Text");
+        results.add("text/plain");
+    }
 
     return results;
 }
@@ -138,13 +357,12 @@ PassRefPtr<FileList> ClipboardChromium::
     if (policy() != ClipboardReadable)
         return FileList::create();
 
-    if (!m_dataObject)
+    if (!m_dataObject || m_dataObject->filenames.isEmpty())
         return FileList::create();
 
-    const Vector<String>& filenames = m_dataObject->filenames();
     RefPtr<FileList> fileList = FileList::create();
-    for (size_t i = 0; i < filenames.size(); ++i)
-        fileList->append(File::create(filenames.at(i)));
+    for (size_t i = 0; i < m_dataObject->filenames.size(); ++i)
+        fileList->append(File::create(m_dataObject->filenames.at(i)));
 
     return fileList.release();
 }
@@ -243,7 +461,7 @@ static void writeImageToDataObject(Chrom
     if (!imageBuffer || !imageBuffer->size())
         return;
 
-    dataObject->setFileContent(imageBuffer);
+    dataObject->fileContent = imageBuffer;
 
     // Determine the filename for the file contents of the image.  We try to
     // use the alt tag if one exists, otherwise we fall back on the suggested
@@ -251,13 +469,13 @@ static void writeImageToDataObject(Chrom
     // in the URL.
     String extension = MIMETypeRegistry::getPreferredExtensionForMIMEType(
         cachedImage->response().mimeType());
-    dataObject->setFileExtension(extension.isEmpty() ? "" : "." + extension);
+    dataObject->fileExtension = extension.isEmpty() ? "" : "." + extension;
     String title = element->getAttribute(altAttr);
     if (title.isEmpty())
         title = cachedImage->response().suggestedFilename();
 
     title = ClipboardChromium::validateFileName(title, dataObject);
-    dataObject->setFileContentFilename(title + dataObject->fileExtension());
+    dataObject->fileContentFilename = title + dataObject->fileExtension;
 }
 
 void ClipboardChromium::declareAndWriteDragImage(Element* element, const KURL& url, const String& title, Frame* frame)
@@ -265,8 +483,8 @@ void ClipboardChromium::declareAndWriteD
     if (!m_dataObject)
         return;
 
-    m_dataObject->setData(mimeTypeURL, url);
-    m_dataObject->setUrlTitle(title);
+    m_dataObject->url = url;
+    m_dataObject->urlTitle = title;
 
     // Write the bytes in the image to the file format.
     writeImageToDataObject(m_dataObject.get(), element, url);
@@ -280,7 +498,7 @@ void ClipboardChromium::declareAndWriteD
         return;
 
     // Put img tag on the clipboard referencing the image
-    m_dataObject->setData(mimeTypeTextHTML, imageToMarkup(fullURL, element));
+    m_dataObject->textHtml = imageToMarkup(fullURL, element);
 }
 
 void ClipboardChromium::writeURL(const KURL& url, const String& title, Frame*)
@@ -288,15 +506,17 @@ void ClipboardChromium::writeURL(const K
     if (!m_dataObject)
         return;
     ASSERT(!url.isEmpty());
-    m_dataObject->setData(mimeTypeURL, url);
-    m_dataObject->setUrlTitle(title);
+    m_dataObject->url = url;
+    m_dataObject->urlTitle = title;
+    m_dataObject->uriList.clear();
+    m_dataObject->uriList.append(url);
 
     // The URL can also be used as plain text.
-    m_dataObject->setData(mimeTypeTextPlain, url.string());
+    m_dataObject->plainText = url.string();
 
     // The URL can also be used as an HTML fragment.
-    m_dataObject->setData(mimeTypeTextHTML, urlToMarkup(url, title));
-    m_dataObject->setHtmlBaseUrl(url);
+    m_dataObject->textHtml = urlToMarkup(url, title);
+    m_dataObject->htmlBaseUrl = url;
 }
 
 void ClipboardChromium::writeRange(Range* selectedRange, Frame* frame)
@@ -305,15 +525,15 @@ void ClipboardChromium::writeRange(Range
     if (!m_dataObject)
          return;
 
-    m_dataObject->setData(mimeTypeTextHTML, createMarkup(selectedRange, 0, AnnotateForInterchange, false, AbsoluteURLs));
-    m_dataObject->setHtmlBaseUrl(frame->document()->url());
+    m_dataObject->textHtml = createMarkup(selectedRange, 0, AnnotateForInterchange, false, AbsoluteURLs);
+    m_dataObject->htmlBaseUrl = frame->document()->url();
 
     String str = frame->editor()->selectedText();
 #if OS(WINDOWS)
     replaceNewlinesWithWindowsStyleNewlines(str);
 #endif
     replaceNBSPWithSpace(str);
-    m_dataObject->setData(mimeTypeTextPlain, str);
+    m_dataObject->plainText = str;
 }
 
 void ClipboardChromium::writePlainText(const String& text)
@@ -326,7 +546,7 @@ void ClipboardChromium::writePlainText(c
     replaceNewlinesWithWindowsStyleNewlines(str);
 #endif
     replaceNBSPWithSpace(str);
-    m_dataObject->setData(mimeTypeTextPlain, str);
+    m_dataObject->plainText = str;
 }
 
 bool ClipboardChromium::hasData()
diff -Naurp WebKit-r68833/WebCore/platform/chromium/ClipboardChromiumWin.cpp wxwebkit/WebCore/platform/chromium/ClipboardChromiumWin.cpp
--- WebKit-r68833/WebCore/platform/chromium/ClipboardChromiumWin.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/platform/chromium/ClipboardChromiumWin.cpp	2010-10-23 03:51:25.980000071 +0400
@@ -44,11 +44,11 @@ String ClipboardChromium::validateFileNa
 {
     // Remove any invalid file system characters.
     String result = title.removeCharacters(&isInvalidFileCharacter);
-    if (result.length() + dataObject->fileExtension().length() + 1 >= MAX_PATH) {
-        if (dataObject->fileExtension().length() + 1 >= MAX_PATH)
-            dataObject->setFileExtension("");
-        if (result.length() + dataObject->fileExtension().length() + 1 >= MAX_PATH)
-            result = result.substring(0, MAX_PATH - dataObject->fileExtension().length() - 1);
+    if (result.length() + dataObject->fileExtension.length() + 1 >= MAX_PATH) {
+        if (dataObject->fileExtension.length() + 1 >= MAX_PATH)
+            dataObject->fileExtension = "";
+        if (result.length() + dataObject->fileExtension.length() + 1 >= MAX_PATH)
+            result = result.substring(0, MAX_PATH - dataObject->fileExtension.length() - 1);
     }
     return result;
 }
diff -Naurp WebKit-r68833/WebCore/platform/chromium/ClipboardMimeTypes.cpp wxwebkit/WebCore/platform/chromium/ClipboardMimeTypes.cpp
--- WebKit-r68833/WebCore/platform/chromium/ClipboardMimeTypes.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/platform/chromium/ClipboardMimeTypes.cpp	2010-10-23 03:51:25.980000071 +0400
@@ -33,12 +33,8 @@
 
 namespace WebCore {
 
-const char mimeTypeText[] = "text/plain";
-const char mimeTypeTextPlain[] = "text/plain";
-const char mimeTypeTextPlainEtc[] = "text/plain;";
-const char mimeTypeTextHTML[] = "text/html";
-const char mimeTypeURL[] = "url";
-const char mimeTypeTextURIList[] = "text/uri-list";
-const char mimeTypeDownloadURL[] = "downloadurl";
+const char textPlainType[] = "text/plain";
+const char textHtmlType[] = "text/html";
+const char textUriListType[] = "text/uri-list";
 
 } // namespace WebCore
diff -Naurp WebKit-r68833/WebCore/platform/chromium/ClipboardMimeTypes.h wxwebkit/WebCore/platform/chromium/ClipboardMimeTypes.h
--- WebKit-r68833/WebCore/platform/chromium/ClipboardMimeTypes.h	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/platform/chromium/ClipboardMimeTypes.h	2010-10-23 03:51:25.980000071 +0400
@@ -33,13 +33,9 @@
 
 namespace WebCore {
 
-extern const char mimeTypeText[];
-extern const char mimeTypeTextPlain[];
-extern const char mimeTypeTextPlainEtc[];
-extern const char mimeTypeTextHTML[];
-extern const char mimeTypeURL[];
-extern const char mimeTypeTextURIList[];
-extern const char mimeTypeDownloadURL[];
+extern const char textPlainType[];
+extern const char textHtmlType[];
+extern const char textUriListType[];
 
 } // namespace WebCore
 
diff -Naurp WebKit-r68833/WebCore/platform/chromium/DragDataChromium.cpp wxwebkit/WebCore/platform/chromium/DragDataChromium.cpp
--- WebKit-r68833/WebCore/platform/chromium/DragDataChromium.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/platform/chromium/DragDataChromium.cpp	2010-10-23 03:51:25.981000071 +0400
@@ -32,7 +32,6 @@
 
 #include "ChromiumBridge.h"
 #include "ChromiumDataObject.h"
-#include "ClipboardMimeTypes.h"
 #include "DocumentFragment.h"
 #include "FileSystem.h"
 #include "KURL.h"
@@ -44,50 +43,50 @@ namespace WebCore {
 
 static bool containsHTML(const ChromiumDataObject* dropData)
 {
-    return dropData->types().contains(mimeTypeTextHTML);
+    return dropData->textHtml.length() > 0;
 }
 
 bool DragData::containsURL(FilenameConversionPolicy filenamePolicy) const
 {
-    return m_platformDragData->types().contains(mimeTypeURL)
-        || (filenamePolicy == ConvertFilenames && m_platformDragData->containsFilenames());
+    return !asURL(filenamePolicy).isEmpty();
 }
 
 String DragData::asURL(FilenameConversionPolicy filenamePolicy, String* title) const
 {
     String url;
-    if (m_platformDragData->types().contains(mimeTypeURL)) {
-        bool ignoredSuccess;
-        url = m_platformDragData->getData(mimeTypeURL, ignoredSuccess);
-        if (title)
-            *title = m_platformDragData->urlTitle();
-    } else if (filenamePolicy == ConvertFilenames && containsFiles()) {
-        url = ChromiumBridge::filePathToURL(ChromiumBridge::getAbsolutePath(m_platformDragData->filenames()[0]));
+    if (m_platformDragData->hasValidURL())
+        url = m_platformDragData->getURL().string();
+    else if (filenamePolicy == ConvertFilenames && !m_platformDragData->filenames.isEmpty()) {
+        String fileName = m_platformDragData->filenames[0];
+        fileName = ChromiumBridge::getAbsolutePath(fileName);
+        url = ChromiumBridge::filePathToURL(fileName).string();
     }
+ 
+    // |title| can be NULL
+    if (title)
+        *title = m_platformDragData->urlTitle;
     return url;
 }
 
 bool DragData::containsFiles() const
 {
-    return m_platformDragData->containsFilenames();
+    return !m_platformDragData->filenames.isEmpty();
 }
 
 void DragData::asFilenames(Vector<String>& result) const
 {
-    const Vector<String>& filenames = m_platformDragData->filenames();
-    for (size_t i = 0; i < filenames.size(); ++i)
-        result.append(filenames[i]);
+    for (size_t i = 0; i < m_platformDragData->filenames.size(); ++i)
+        result.append(m_platformDragData->filenames[i]);
 }
 
 bool DragData::containsPlainText() const
 {
-    return m_platformDragData->types().contains(mimeTypeTextPlain);
+    return !m_platformDragData->plainText.isEmpty();
 }
 
 String DragData::asPlainText() const
 {
-    bool ignoredSuccess;
-    return m_platformDragData->getData(mimeTypeTextPlain, ignoredSuccess);
+    return m_platformDragData->plainText;
 }
 
 bool DragData::containsColor() const
@@ -102,8 +101,8 @@ bool DragData::canSmartReplace() const
     // This is allowed whenever the drag data contains a 'range' (ie.,
     // ClipboardWin::writeRange is called).  For example, dragging a link
     // should not result in a space being added.
-    return m_platformDragData->types().contains(mimeTypeTextPlain)
-        && !m_platformDragData->types().contains(mimeTypeURL);
+    return !m_platformDragData->plainText.isEmpty()
+        && !m_platformDragData->hasValidURL();
 }
 
 bool DragData::containsCompatibleContent() const
@@ -135,10 +134,9 @@ PassRefPtr<DocumentFragment> DragData::a
         //    return fragment;
     }
 
-    if (m_platformDragData->types().contains(mimeTypeTextHTML)) {
-        bool ignoredSuccess;
+    if (!m_platformDragData->textHtml.isEmpty()) {
         RefPtr<DocumentFragment> fragment = createFragmentFromMarkup(doc,
-            m_platformDragData->getData(mimeTypeTextHTML, ignoredSuccess), m_platformDragData->htmlBaseUrl(), FragmentScriptingNotAllowed);
+            m_platformDragData->textHtml, m_platformDragData->htmlBaseUrl, FragmentScriptingNotAllowed);
         return fragment.release();
     }
 
diff -Naurp WebKit-r68833/WebCore/platform/chromium/ReadableDataObject.cpp wxwebkit/WebCore/platform/chromium/ReadableDataObject.cpp
--- WebKit-r68833/WebCore/platform/chromium/ReadableDataObject.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/platform/chromium/ReadableDataObject.cpp	2010-10-23 03:51:25.986000071 +0400
@@ -81,7 +81,7 @@ String ReadableDataObject::getURL(String
     if (!title)
         title = &ignoredTitle;
     ChromiumBridge::clipboardReadData(
-        clipboardBuffer(m_isForDragging), mimeTypeTextURIList, url, *title);
+        clipboardBuffer(m_isForDragging), textUriListType, url, *title);
     return url;
 }
 
@@ -92,7 +92,7 @@ String ReadableDataObject::getHTML(Strin
     if (!baseURL)
         baseURL = &ignoredBaseURL;
     ChromiumBridge::clipboardReadData(
-        clipboardBuffer(m_isForDragging), mimeTypeTextHTML, html, *baseURL);
+        clipboardBuffer(m_isForDragging), textHtmlType, html, *baseURL);
     return html;
 }
 
diff -Naurp WebKit-r68833/WebCore/platform/chromium/WritableDataObject.cpp wxwebkit/WebCore/platform/chromium/WritableDataObject.cpp
--- WebKit-r68833/WebCore/platform/chromium/WritableDataObject.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/platform/chromium/WritableDataObject.cpp	2010-10-23 03:51:25.989000071 +0400
@@ -49,9 +49,9 @@ WritableDataObject::WritableDataObject(b
 void WritableDataObject::clearData(const String& type)
 {
     m_dataMap.remove(type);
-    if (type == mimeTypeTextURIList)
+    if (type == textUriListType)
         m_urlTitle = "";
-    else if (type == mimeTypeTextHTML)
+    else if (type == textHtmlType)
         m_htmlBaseURL = KURL();
 }
 
@@ -81,22 +81,22 @@ bool WritableDataObject::setData(const S
         return true;
     }
     m_dataMap.set(type, data);
-    if (type == mimeTypeTextURIList)
+    if (type == textUriListType)
         m_urlTitle = "";
-    else if (type == mimeTypeTextHTML)
+    else if (type == textHtmlType)
         m_htmlBaseURL = KURL();
     return true;
 }
 
 void WritableDataObject::setURL(const String& url, const String& title)
 {
-    setData(mimeTypeTextURIList, url);
+    setData(textUriListType, url);
     m_urlTitle = title;
 }
 
 void WritableDataObject::setHTML(const String& html, const KURL& baseURL)
 {
-    setData(mimeTypeTextHTML, html);
+    setData(textHtmlType, html);
     m_htmlBaseURL = baseURL;
 }
 
diff -Naurp WebKit-r68833/WebCore/platform/graphics/ANGLEWebKitBridge.cpp wxwebkit/WebCore/platform/graphics/ANGLEWebKitBridge.cpp
--- WebKit-r68833/WebCore/platform/graphics/ANGLEWebKitBridge.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/platform/graphics/ANGLEWebKitBridge.cpp	2010-10-23 03:51:25.994000071 +0400
@@ -44,6 +44,8 @@ ANGLEWebKitBridge::~ANGLEWebKitBridge()
         ShDestruct(m_fragmentCompiler);
         ShDestruct(m_vertexCompiler);
     }
+    
+    ShFinalize();
 }
 
 bool ANGLEWebKitBridge::validateShaderSource(const char* shaderSource, ANGLEShaderType shaderType, String& translatedShaderSource, String& shaderValidationLog)
diff -Naurp WebKit-r68833/WebCore/platform/graphics/ContextShadow.cpp wxwebkit/WebCore/platform/graphics/ContextShadow.cpp
--- WebKit-r68833/WebCore/platform/graphics/ContextShadow.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/platform/graphics/ContextShadow.cpp	2010-10-23 03:51:25.995000071 +0400
@@ -154,7 +154,7 @@ void ContextShadow::calculateLayerBoundi
     m_layerRect = enclosingIntRect(destinationRect);
 
     // We expand the area by the blur radius * 2 to give extra space for the blur transition.
-    m_layerRect.inflate((m_type == BlurShadow) ? m_blurRadius * 2 : 0);
+    m_layerRect.inflate((m_type == BlurShadow) ? ceil(m_blurRadius * 2) : 0);
 
     if (!clipRect.contains(m_layerRect)) {
         // No need to have the buffer larger than the clip.
@@ -167,7 +167,7 @@ void ContextShadow::calculateLayerBoundi
         // We adjust again because the pixels at the borders are still
         // potentially affected by the pixels outside the buffer.
         if (m_type == BlurShadow)
-            m_layerRect.inflate((m_type == BlurShadow) ? m_blurRadius * 2 : 0);
+            m_layerRect.inflate((m_type == BlurShadow) ? ceil(m_blurRadius * 2) : 0);
     }
 }
 
diff -Naurp WebKit-r68833/WebCore/platform/win/PlatformScreenWin.cpp wxwebkit/WebCore/platform/win/PlatformScreenWin.cpp
--- WebKit-r68833/WebCore/platform/win/PlatformScreenWin.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/platform/win/PlatformScreenWin.cpp	2010-10-23 03:51:26.159000070 +0400
@@ -68,18 +68,14 @@ static DEVMODE deviceInfoForWidget(Widge
 int screenDepth(Widget* widget)
 {
     DEVMODE deviceInfo = deviceInfoForWidget(widget);
-    if (deviceInfo.dmBitsPerPel == 32) {
-        // Some video drivers return 32, but this function is supposed to ignore the alpha
-        // component. See <http://webkit.org/b/42972>.
-        return 24;
-    }
     return deviceInfo.dmBitsPerPel;
 }
 
 int screenDepthPerComponent(Widget* widget)
 {
     // FIXME: Assumes RGB -- not sure if this is right.
-    return screenDepth(widget) / 3;
+    DEVMODE deviceInfo = deviceInfoForWidget(widget);
+    return deviceInfo.dmBitsPerPel / 3;
 }
 
 bool screenIsMonochrome(Widget* widget)
diff -Naurp WebKit-r68833/WebCore/rendering/CounterNode.cpp wxwebkit/WebCore/rendering/CounterNode.cpp
--- WebKit-r68833/WebCore/rendering/CounterNode.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/CounterNode.cpp	2010-10-23 03:51:26.179000070 +0400
@@ -41,11 +41,6 @@ CounterNode::CounterNode(RenderObject* o
 {
 }
 
-PassRefPtr<CounterNode> CounterNode::create(RenderObject* renderer, bool hasResetType, int value)
-{
-    return adoptRef(new CounterNode(renderer, hasResetType, value));
-}
-
 CounterNode* CounterNode::nextInPreOrderAfterChildren(const CounterNode* stayWithin) const
 {
     if (this == stayWithin)
diff -Naurp WebKit-r68833/WebCore/rendering/CounterNode.h wxwebkit/WebCore/rendering/CounterNode.h
--- WebKit-r68833/WebCore/rendering/CounterNode.h	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/CounterNode.h	2010-10-23 03:51:26.179000070 +0400
@@ -24,7 +24,6 @@
 
 #include <wtf/Forward.h>
 #include <wtf/Noncopyable.h>
-#include <wtf/RefCounted.h>
 
 // This implements a counter tree that is used for finding parents in counters() lookup,
 // and for propagating count changes when nodes are added or removed.
@@ -39,9 +38,9 @@ namespace WebCore {
 
 class RenderObject;
 
-class CounterNode : public RefCounted<CounterNode> {
+class CounterNode : public Noncopyable {
 public:
-    static PassRefPtr<CounterNode> create(RenderObject*, bool isReset, int value);
+    CounterNode(RenderObject*, bool isReset, int value);
 
     bool actsAsReset() const { return m_hasResetType || !m_parent; }
     bool hasResetType() const { return m_hasResetType; }
@@ -65,7 +64,6 @@ public:
     void removeChild(CounterNode*, const AtomicString& identifier);
 
 private:
-    CounterNode(RenderObject*, bool isReset, int value);
     int computeCountInParent() const;
     void recount(const AtomicString& identifier);
 
diff -Naurp WebKit-r68833/WebCore/rendering/InlineBox.h wxwebkit/WebCore/rendering/InlineBox.h
--- WebKit-r68833/WebCore/rendering/InlineBox.h	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/InlineBox.h	2010-10-23 03:51:26.180000070 +0400
@@ -251,9 +251,8 @@ public:
     unsigned char bidiLevel() const { return m_bidiEmbeddingLevel; }
     void setBidiLevel(unsigned char level) { m_bidiEmbeddingLevel = level; }
     TextDirection direction() const { return m_bidiEmbeddingLevel % 2 ? RTL : LTR; }
-    bool isLeftToRightDirection() const { return direction() == LTR; }
-    int caretLeftmostOffset() const { return isLeftToRightDirection() ? caretMinOffset() : caretMaxOffset(); }
-    int caretRightmostOffset() const { return isLeftToRightDirection() ? caretMaxOffset() : caretMinOffset(); }
+    int caretLeftmostOffset() const { return direction() == LTR ? caretMinOffset() : caretMaxOffset(); }
+    int caretRightmostOffset() const { return direction() == LTR ? caretMaxOffset() : caretMinOffset(); }
 
     virtual void clearTruncation() { }
 
diff -Naurp WebKit-r68833/WebCore/rendering/InlineFlowBox.cpp wxwebkit/WebCore/rendering/InlineFlowBox.cpp
--- WebKit-r68833/WebCore/rendering/InlineFlowBox.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/InlineFlowBox.cpp	2010-10-23 03:51:26.181000070 +0400
@@ -209,7 +209,7 @@ void InlineFlowBox::determineSpacingForF
 
     // The root inline box never has borders/margins/padding.
     if (parent()) {
-        bool ltr = renderer()->style()->isLeftToRightDirection();
+        bool ltr = renderer()->style()->direction() == LTR;
 
         // Check to see if all initial lines are unconstructed.  If so, then
         // we know the inline began on this line (unless we are a continuation).
@@ -309,7 +309,7 @@ int InlineFlowBox::placeBoxesInInlineDir
             xPos += text->logicalWidth();
         } else {
             if (curr->renderer()->isPositioned()) {
-                if (curr->renderer()->parent()->style()->isLeftToRightDirection())
+                if (curr->renderer()->parent()->style()->direction() == LTR)
                     curr->setX(xPos);
                 else
                     // Our offset that we cache needs to be from the edge of the right border box and
@@ -945,7 +945,7 @@ void InlineFlowBox::paintTextDecorations
         if (rootLine->ellipsisBox()) {
             int ellipsisX = m_x + rootLine->ellipsisBox()->x();
             int ellipsisWidth = rootLine->ellipsisBox()->logicalWidth();
-            bool ltr = renderer()->style()->isLeftToRightDirection();
+            bool ltr = renderer()->style()->direction() == LTR;
             if (rootLine == this) {
                 // Trim w and x so that the underline isn't drawn underneath the ellipsis.
                 // ltr: is our right edge farther right than the right edge of the ellipsis.
diff -Naurp WebKit-r68833/WebCore/rendering/InlineIterator.h wxwebkit/WebCore/rendering/InlineIterator.h
--- WebKit-r68833/WebCore/rendering/InlineIterator.h	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/InlineIterator.h	2010-10-23 03:51:26.181000070 +0400
@@ -220,7 +220,7 @@ ALWAYS_INLINE WTF::Unicode::Direction In
         return WTF::Unicode::direction(c);
 
     if (obj && obj->isListMarker())
-        return obj->style()->isLeftToRightDirection() ? WTF::Unicode::LeftToRight : WTF::Unicode::RightToLeft;
+        return obj->style()->direction() == LTR ? WTF::Unicode::LeftToRight : WTF::Unicode::RightToLeft;
 
     return WTF::Unicode::OtherNeutral;
 }
diff -Naurp WebKit-r68833/WebCore/rendering/InlineTextBox.cpp wxwebkit/WebCore/rendering/InlineTextBox.cpp
--- WebKit-r68833/WebCore/rendering/InlineTextBox.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/InlineTextBox.cpp	2010-10-23 03:51:26.181000070 +0400
@@ -137,7 +137,7 @@ IntRect InlineTextBox::selectionRect(int
         ePos = len;
     }
 
-    IntRect r = enclosingIntRect(f.selectionRectForText(TextRun(characters, len, textObj->allowTabs(), textPos(), m_toAdd, !isLeftToRightDirection(), m_dirOverride),
+    IntRect r = enclosingIntRect(f.selectionRectForText(TextRun(characters, len, textObj->allowTabs(), textPos(), m_toAdd, direction() == RTL, m_dirOverride),
                                                         IntPoint(tx + m_x, ty + selTop), selHeight, sPos, ePos));
     if (r.x() > tx + m_x + m_logicalWidth)
         r.setWidth(0);
@@ -198,7 +198,7 @@ int InlineTextBox::placeEllipsisBox(bool
         // The inline box may have different directionality than it's parent.  Since truncation
         // behavior depends both on both the parent and the inline block's directionality, we
         // must keep track of these separately.
-        bool ltr = isLeftToRightDirection();
+        bool ltr = direction() == LTR;
         if (ltr != flowIsLTR) {
           // Width in pixels of the visible portion of the box, excluding the ellipsis.
           int visibleBoxWidth = visibleRightEdge - visibleLeftEdge  - ellipsisWidth;
@@ -382,7 +382,8 @@ void InlineTextBox::paint(PaintInfo& pai
         return;
 
     if (m_truncation != cNoTruncation) {
-        if (renderer()->containingBlock()->style()->isLeftToRightDirection() != isLeftToRightDirection()) {
+        TextDirection flowDirection = renderer()->containingBlock()->style()->direction();
+        if (flowDirection != direction()) {
             // Make the visible fragment of text hug the edge closest to the rest of the run by moving the origin
             // at which we start drawing text.
             // e.g. In the case of LTR text truncated in an RTL Context, the correct behavior is:
@@ -394,7 +395,7 @@ void InlineTextBox::paint(PaintInfo& pai
             int widthOfVisibleText = toRenderText(renderer())->width(m_start, m_truncation, textPos(), m_firstLine);
             int widthOfHiddenText = m_logicalWidth - widthOfVisibleText;
             // FIXME: The hit testing logic also needs to take this translation int account.
-            tx += isLeftToRightDirection() ? widthOfHiddenText : -widthOfHiddenText;
+            tx += direction() == LTR ? widthOfHiddenText : -widthOfHiddenText;
         }
     }
 
@@ -503,7 +504,7 @@ void InlineTextBox::paint(PaintInfo& pai
 
     int baseline = renderer()->style(m_firstLine)->font().ascent();
     IntPoint textOrigin(m_x + tx, m_y + ty + baseline);
-    TextRun textRun(characters, length, textRenderer()->allowTabs(), textPos(), m_toAdd, !isLeftToRightDirection(), m_dirOverride || styleToUse->visuallyOrdered());
+    TextRun textRun(characters, length, textRenderer()->allowTabs(), textPos(), m_toAdd, direction() == RTL, m_dirOverride || styleToUse->visuallyOrdered());
 
     int sPos = 0;
     int ePos = 0;
@@ -634,7 +635,7 @@ void InlineTextBox::paintSelection(Graph
 
     context->clip(IntRect(m_x + tx, y + ty, m_logicalWidth, h));
     context->drawHighlightForText(font, TextRun(characters, length, textRenderer()->allowTabs(), textPos(), m_toAdd, 
-                                  !isLeftToRightDirection(), m_dirOverride || style->visuallyOrdered()),
+                                  direction() == RTL, m_dirOverride || style->visuallyOrdered()),
                                   IntPoint(m_x + tx, y + ty), h, c, style->colorSpace(), sPos, ePos);
     context->restore();
 }
@@ -657,7 +658,7 @@ void InlineTextBox::paintCompositionBack
     int y = selectionTop();
     int h = selectionHeight();
     context->drawHighlightForText(font, TextRun(textRenderer()->text()->characters() + m_start, m_len, textRenderer()->allowTabs(), textPos(), m_toAdd,
-                                  !isLeftToRightDirection(), m_dirOverride || style->visuallyOrdered()),
+                                  direction() == RTL, m_dirOverride || style->visuallyOrdered()),
                                   IntPoint(m_x + tx, y + ty), h, c, style->colorSpace(), sPos, ePos);
     context->restore();
 }
@@ -693,7 +694,7 @@ void InlineTextBox::paintDecoration(Grap
     int width = m_logicalWidth;
     if (m_truncation != cNoTruncation) {
         width = toRenderText(renderer())->width(m_start, m_truncation, textPos(), m_firstLine);
-        if (!isLeftToRightDirection())
+        if (direction() == RTL)
             tx += (m_logicalWidth - width);
     }
     
@@ -812,7 +813,7 @@ void InlineTextBox::paintSpellingOrGramm
 
         // Calculate start & width
         IntPoint startPoint(tx + m_x, ty + selectionTop());
-        TextRun run(textRenderer()->text()->characters() + m_start, m_len, textRenderer()->allowTabs(), textPos(), m_toAdd, !isLeftToRightDirection(), m_dirOverride || style->visuallyOrdered());
+        TextRun run(textRenderer()->text()->characters() + m_start, m_len, textRenderer()->allowTabs(), textPos(), m_toAdd, direction() == RTL, m_dirOverride || style->visuallyOrdered());
         int h = selectionHeight();
         
         IntRect markerRect = enclosingIntRect(font.selectionRectForText(run, startPoint, h, startPosition, endPosition));
@@ -857,7 +858,7 @@ void InlineTextBox::paintTextMatchMarker
     
     int sPos = max(marker.startOffset - m_start, (unsigned)0);
     int ePos = min(marker.endOffset - m_start, (unsigned)m_len);    
-    TextRun run(textRenderer()->text()->characters() + m_start, m_len, textRenderer()->allowTabs(), textPos(), m_toAdd, !isLeftToRightDirection(), m_dirOverride || style->visuallyOrdered());
+    TextRun run(textRenderer()->text()->characters() + m_start, m_len, textRenderer()->allowTabs(), textPos(), m_toAdd, direction() == RTL, m_dirOverride || style->visuallyOrdered());
     
     // Always compute and store the rect associated with this marker. The computed rect is in absolute coordinates.
     IntRect markerRect = enclosingIntRect(font.selectionRectForText(run, IntPoint(m_x, y), h, sPos, ePos));
@@ -885,7 +886,7 @@ void InlineTextBox::computeRectForReplac
     
     int sPos = max(marker.startOffset - m_start, (unsigned)0);
     int ePos = min(marker.endOffset - m_start, (unsigned)m_len);    
-    TextRun run(textRenderer()->text()->characters() + m_start, m_len, textRenderer()->allowTabs(), textPos(), m_toAdd, !isLeftToRightDirection(), m_dirOverride || style->visuallyOrdered());
+    TextRun run(textRenderer()->text()->characters() + m_start, m_len, textRenderer()->allowTabs(), textPos(), m_toAdd, direction() == RTL, m_dirOverride || style->visuallyOrdered());
     IntPoint startPoint = IntPoint(m_x, y);
     
     // Compute and store the rect associated with this marker.
@@ -1030,7 +1031,7 @@ int InlineTextBox::textPos() const
         return 0;
         
     RenderBlock* blockElement = renderer()->containingBlock();
-    return !isLeftToRightDirection() ? x() - blockElement->borderRight() - blockElement->paddingRight()
+    return direction() == RTL ? x() - blockElement->borderRight() - blockElement->paddingRight()
                       : x() - blockElement->borderLeft() - blockElement->paddingLeft();
 }
 
@@ -1042,7 +1043,7 @@ int InlineTextBox::offsetForPosition(int
     RenderText* text = toRenderText(renderer());
     RenderStyle* style = text->style(m_firstLine);
     const Font* f = &style->font();
-    return f->offsetForPosition(TextRun(textRenderer()->text()->characters() + m_start, m_len, textRenderer()->allowTabs(), textPos(), m_toAdd, !isLeftToRightDirection(), m_dirOverride || style->visuallyOrdered()),
+    return f->offsetForPosition(TextRun(textRenderer()->text()->characters() + m_start, m_len, textRenderer()->allowTabs(), textPos(), m_toAdd, direction() == RTL, m_dirOverride || style->visuallyOrdered()),
                                 _x - m_x, includePartialGlyphs);
 }
 
@@ -1056,10 +1057,10 @@ int InlineTextBox::positionForOffset(int
 
     RenderText* text = toRenderText(renderer());
     const Font& f = text->style(m_firstLine)->font();
-    int from = !isLeftToRightDirection() ? offset - m_start : 0;
-    int to = !isLeftToRightDirection() ? m_len : offset - m_start;
+    int from = direction() == RTL ? offset - m_start : 0;
+    int to = direction() == RTL ? m_len : offset - m_start;
     // FIXME: Do we need to add rightBearing here?
-    return enclosingIntRect(f.selectionRectForText(TextRun(text->text()->characters() + m_start, m_len, textRenderer()->allowTabs(), textPos(), m_toAdd, !isLeftToRightDirection(), m_dirOverride),
+    return enclosingIntRect(f.selectionRectForText(TextRun(text->text()->characters() + m_start, m_len, textRenderer()->allowTabs(), textPos(), m_toAdd, direction() == RTL, m_dirOverride),
                                                    IntPoint(m_x, 0), 0, from, to)).right();
 }
 
diff -Naurp WebKit-r68833/WebCore/rendering/RenderBlock.cpp wxwebkit/WebCore/rendering/RenderBlock.cpp
--- WebKit-r68833/WebCore/rendering/RenderBlock.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderBlock.cpp	2010-10-23 03:51:26.185000070 +0400
@@ -1324,7 +1324,7 @@ bool RenderBlock::expandsToEncloseOverha
 void RenderBlock::adjustPositionedBlock(RenderBox* child, const MarginInfo& marginInfo)
 {
     if (child->style()->hasStaticX()) {
-        if (style()->isLeftToRightDirection())
+        if (style()->direction() == LTR)
             child->layer()->setStaticX(borderLeft() + paddingLeft());
         else
             child->layer()->setStaticX(borderRight() + paddingRight());
@@ -1509,7 +1509,7 @@ int RenderBlock::collapseMargins(RenderB
     if (marginInfo.quirkContainer() && marginInfo.atBeforeSideOfBlock() && (posTop - negTop))
         marginInfo.setMarginBeforeQuirk(topQuirk);
 
-    int beforeCollapseY = logicalHeight();
+    int beforeCollapseY = height();
     int ypos = beforeCollapseY;
     if (child->isSelfCollapsingBlock()) {
         // This child has no height.  We need to compute our
@@ -1529,20 +1529,20 @@ int RenderBlock::collapseMargins(RenderB
             // is correct, since it could have overflowing content
             // that needs to be positioned correctly (e.g., a block that
             // had a specified height of 0 but that actually had subcontent).
-            ypos = logicalHeight() + collapsedTopPos - collapsedTopNeg;
+            ypos = height() + collapsedTopPos - collapsedTopNeg;
     }
     else {
         if (child->style()->marginBeforeCollapse() == MSEPARATE) {
-            setLogicalHeight(logicalHeight() + marginInfo.margin() + child->marginTop());
-            ypos = logicalHeight();
+            setLogicalHeight(height() + marginInfo.margin() + child->marginTop());
+            ypos = height();
         }
         else if (!marginInfo.atBeforeSideOfBlock() ||
             (!marginInfo.canCollapseMarginBeforeWithChildren()
              && (!document()->inQuirksMode() || !marginInfo.quirkContainer() || !marginInfo.marginBeforeQuirk()))) {
             // We're collapsing with a previous sibling's margins and not
             // with the top of the block.
-            setLogicalHeight(logicalHeight() + max(marginInfo.posMargin(), posTop) - max(marginInfo.negMargin(), negTop));
-            ypos = logicalHeight();
+            setLogicalHeight(height() + max(marginInfo.posMargin(), posTop) - max(marginInfo.negMargin(), negTop));
+            ypos = height();
         }
 
         marginInfo.setPosMargin(child->maxMarginAfter(PositiveMargin));
@@ -1558,7 +1558,7 @@ int RenderBlock::collapseMargins(RenderB
     if (paginated && ypos > beforeCollapseY) {
         int oldY = ypos;
         ypos = min(ypos, nextPageTop(beforeCollapseY));
-        setLogicalHeight(logicalHeight() + (ypos - oldY));
+        setLogicalHeight(height() + (ypos - oldY));
     }
     return ypos;
 }
@@ -1645,33 +1645,54 @@ int RenderBlock::estimateLogicalTopPosit
 
 void RenderBlock::determineLogicalLeftPositionForChild(RenderBox* child)
 {
-    int startPosition = borderStart() + paddingStart();
-    int totalAvailableLogicalWidth = borderAndPaddingLogicalWidth() + availableLogicalWidth();
-
-    // Add in our start margin.
-    int childMarginStart = marginStartForChild(child);
-    int newPosition = startPosition + childMarginStart;
+    int xPos = borderLeft() + paddingLeft();
+    if (style()->direction() == LTR) {
+        // Add in our left margin.
+        int chPos = xPos + child->marginLeft();
         
-    // Some objects (e.g., tables, horizontal rules, overflow:auto blocks) avoid floats.  They need
-    // to shift over as necessary to dodge any floats that might get in the way.
-    if (child->avoidsFloats()) {
-        int startOff = style()->isLeftToRightDirection() ? logicalLeftOffsetForLine(logicalHeight(), false) : totalAvailableLogicalWidth - logicalRightOffsetForLine(logicalHeight(), false);
-        if (style()->textAlign() != WEBKIT_CENTER && !child->style()->marginStartUsing(style()).isAuto()) {
-            if (childMarginStart < 0)
-                startOff += childMarginStart;
-            newPosition = max(newPosition, startOff); // Let the float sit in the child's margin if it can fit.
-        } else if (startOff != startPosition) {
-            // The object is shifting to the "end" side of the block. The object might be centered, so we need to
-            // recalculate our inline direction margins. Note that the containing block content
-            // width computation will take into account the delta between |startOff| and |startPosition|
-            // so that we can just pass the content width in directly to the |computeMarginsInContainingBlockInlineDirection|
-            // function.
-            child->computeInlineDirectionMargins(this, availableLogicalWidthForLine(logicalTopForChild(child), false), logicalWidthForChild(child));
-            newPosition = startOff + marginStartForChild(child);
+        // Some objects (e.g., tables, horizontal rules, overflow:auto blocks) avoid floats.  They need
+        // to shift over as necessary to dodge any floats that might get in the way.
+        if (child->avoidsFloats()) {
+            int leftOff = logicalLeftOffsetForLine(height(), false);
+            if (style()->textAlign() != WEBKIT_CENTER && child->style()->marginLeft().type() != Auto) {
+                if (child->marginLeft() < 0)
+                    leftOff += child->marginLeft();
+                chPos = max(chPos, leftOff); // Let the float sit in the child's margin if it can fit.
+            }
+            else if (leftOff != xPos) {
+                // The object is shifting right. The object might be centered, so we need to
+                // recalculate our horizontal margins. Note that the containing block content
+                // width computation will take into account the delta between |leftOff| and |xPos|
+                // so that we can just pass the content width in directly to the |computeMarginsInContainingBlockInlineDirection|
+                // function.
+                child->computeInlineDirectionMargins(this, availableLogicalWidthForLine(child->y(), false), child->width());
+                chPos = leftOff + child->marginLeft();
+            }
+        }
+        view()->addLayoutDelta(IntSize(child->x() - chPos, 0));
+        child->setLocation(chPos, child->y());
+    } else {
+        xPos += availableLogicalWidth();
+        int chPos = xPos - (child->width() + child->marginRight());
+        if (child->avoidsFloats()) {
+            int rightOff = logicalRightOffsetForLine(height(), false);
+            if (style()->textAlign() != WEBKIT_CENTER && child->style()->marginRight().type() != Auto) {
+                if (child->marginRight() < 0)
+                    rightOff -= child->marginRight();
+                chPos = min(chPos, rightOff - child->width()); // Let the float sit in the child's margin if it can fit.
+            } else if (rightOff != xPos) {
+                // The object is shifting left. The object might be centered, so we need to
+                // recalculate our horizontal margins. Note that the containing block content
+                // width computation will take into account the delta between |rightOff| and |xPos|
+                // so that we can just pass the content width in directly to the |computeInlineDirectionMargins|
+                // function.
+                child->computeInlineDirectionMargins(this, availableLogicalWidthForLine(child->y(), false), child->width());
+                chPos = rightOff - child->marginRight() - child->width();
+            }
         }
+        view()->addLayoutDelta(IntSize(child->x() - chPos, 0));
+        child->setLocation(chPos, child->y());
     }
-
-    setLogicalLeftForChild(child, style()->isLeftToRightDirection() ? newPosition : totalAvailableLogicalWidth - newPosition - logicalWidthForChild(child));
 }
 
 void RenderBlock::setCollapsedBottomMargin(const MarginInfo& marginInfo)
@@ -1699,30 +1720,19 @@ void RenderBlock::handleAfterSideOfBlock
     // If we can't collapse with children then go ahead and add in the bottom margin.
     if (!marginInfo.canCollapseWithMarginAfter() && !marginInfo.canCollapseWithMarginBefore()
         && (!document()->inQuirksMode() || !marginInfo.quirkContainer() || !marginInfo.marginAfterQuirk()))
-        setLogicalHeight(logicalHeight() + marginInfo.margin());
+        setLogicalHeight(height() + marginInfo.margin());
         
     // Now add in our bottom border/padding.
-    setLogicalHeight(logicalHeight() + bottom);
+    setLogicalHeight(height() + bottom);
 
     // Negative margins can cause our height to shrink below our minimal height (border/padding).
     // If this happens, ensure that the computed height is increased to the minimal height.
-    setLogicalHeight(max(logicalHeight(), top + bottom));
+    setLogicalHeight(max(height(), top + bottom));
 
     // Update our bottom collapsed margin info.
     setCollapsedBottomMargin(marginInfo);
 }
 
-void RenderBlock::setLogicalLeftForChild(RenderBox* child, int logicalLeft)
-{
-    if (style()->isVerticalBlockFlow()) {
-        view()->addLayoutDelta(IntSize(child->x() - logicalLeft, 0));
-        child->setLocation(logicalLeft, child->y());
-    } else {
-        view()->addLayoutDelta(IntSize(0, child->y() - logicalLeft));
-        child->setLocation(child->x(), logicalLeft);
-    }
-}
-
 void RenderBlock::setLogicalTopForChild(RenderBox* child, int logicalTop)
 {
     if (style()->isVerticalBlockFlow()) {
@@ -2123,14 +2133,14 @@ void RenderBlock::paintColumnRules(Paint
     // We need to do multiple passes, breaking up our child painting into strips.
     ColumnInfo* colInfo = columnInfo();
     unsigned colCount = columnCount(colInfo);
-    int currXOffset = style()->isLeftToRightDirection() ? 0 : contentWidth();
+    int currXOffset = style()->direction() == LTR ? 0 : contentWidth();
     int ruleAdd = borderLeft() + paddingLeft();
-    int ruleX = style()->isLeftToRightDirection() ? 0 : contentWidth();
+    int ruleX = style()->direction() == LTR ? 0 : contentWidth();
     for (unsigned i = 0; i < colCount; i++) {
         IntRect colRect = columnRectAt(colInfo, i);
 
         // Move to the next position.
-        if (style()->isLeftToRightDirection()) {
+        if (style()->direction() == LTR) {
             ruleX += colRect.width() + colGap / 2;
             currXOffset += colRect.width() + colGap;
         } else {
@@ -2145,7 +2155,7 @@ void RenderBlock::paintColumnRules(Paint
             int ruleTop = ty + borderTop() + paddingTop();
             int ruleBottom = ruleTop + contentHeight();
             drawLineForBoxSide(paintInfo.context, ruleStart, ruleTop, ruleEnd, ruleBottom,
-                               style()->isLeftToRightDirection() ? BSLeft : BSRight, ruleColor, ruleStyle, 0, 0);
+                               style()->direction() == LTR ? BSLeft : BSRight, ruleColor, ruleStyle, 0, 0);
         }
         
         ruleX = currXOffset;
@@ -2161,7 +2171,7 @@ void RenderBlock::paintColumnContents(Pa
     unsigned colCount = columnCount(colInfo);
     if (!colCount)
         return;
-    int currXOffset = style()->isLeftToRightDirection() ? 0 : contentWidth() - columnRectAt(colInfo, 0).width();
+    int currXOffset = style()->direction() == LTR ? 0 : contentWidth() - columnRectAt(colInfo, 0).width();
     int currYOffset = 0;
     for (unsigned i = 0; i < colCount; i++) {
         // For each rect, we clip to the rect, and then we adjust our coords.
@@ -2189,7 +2199,7 @@ void RenderBlock::paintColumnContents(Pa
         }
         
         // Move to the next position.
-        if (style()->isLeftToRightDirection())
+        if (style()->direction() == LTR)
             currXOffset += colRect.width() + colGap;
         else
             currXOffset -= (colRect.width() + colGap);
@@ -2804,7 +2814,7 @@ IntRect RenderBlock::fillRightSelectionG
 
 void RenderBlock::getHorizontalSelectionGapInfo(SelectionState state, bool& leftGap, bool& rightGap)
 {
-    bool ltr = style()->isLeftToRightDirection();
+    bool ltr = style()->direction() == LTR;
     leftGap = (state == RenderObject::SelectionInside) ||
               (state == RenderObject::SelectionEnd && ltr) ||
               (state == RenderObject::SelectionStart && !ltr);
@@ -3209,6 +3219,11 @@ HashSet<RenderBox*>* RenderBlock::percen
     return gPercentHeightDescendantsMap ? gPercentHeightDescendantsMap->get(this) : 0;
 }
 
+int RenderBlock::logicalLeftOffsetForContent() const
+{
+    return borderLeft() + paddingLeft();
+}
+
 int RenderBlock::logicalLeftOffsetForLine(int y, int fixedOffset, bool applyTextIndent, int* heightRemaining) const
 {
     int left = fixedOffset;
@@ -3227,7 +3242,7 @@ int RenderBlock::logicalLeftOffsetForLin
         }
     }
 
-    if (applyTextIndent && style()->isLeftToRightDirection()) {
+    if (applyTextIndent && style()->direction() == LTR) {
         int cw = 0;
         if (style()->textIndent().isPercent())
             cw = containingBlock()->availableLogicalWidth();
@@ -3237,6 +3252,11 @@ int RenderBlock::logicalLeftOffsetForLin
     return left;
 }
 
+int RenderBlock::logicalRightOffsetForContent() const
+{
+    return borderLeft() + paddingLeft() + availableLogicalWidth();
+}
+
 int RenderBlock::logicalRightOffsetForLine(int y, int fixedOffset, bool applyTextIndent, int* heightRemaining) const
 {
     int right = fixedOffset;
@@ -3256,7 +3276,7 @@ int RenderBlock::logicalRightOffsetForLi
         }
     }
     
-    if (applyTextIndent && !style()->isLeftToRightDirection()) {
+    if (applyTextIndent && style()->direction() == RTL) {
         int cw = 0;
         if (style()->textIndent().isPercent())
             cw = containingBlock()->availableLogicalWidth();
@@ -3451,7 +3471,7 @@ int RenderBlock::rightmostPosition(bool 
 
     if (hasColumns()) {
         // This only matters for LTR
-        if (style()->isLeftToRightDirection()) {
+        if (style()->direction() == LTR) {
             ColumnInfo* colInfo = columnInfo();
             unsigned count = columnCount(colInfo);
             if (count)
@@ -3479,7 +3499,7 @@ int RenderBlock::rightmostPosition(bool 
                 
                 // If this node is a root editable element, then the rightmostPosition should account for a caret at the end.
                 // FIXME: Need to find another way to do this, since scrollbars could show when we don't want them to.
-                if (node() && node()->isContentEditable() && node() == node()->rootEditableElement() && style()->isLeftToRightDirection() && !paddingRight())
+                if (node() && node()->isContentEditable() && node() == node()->rootEditableElement() && style()->direction() == LTR && !paddingRight())
                     childRightEdge += 1;
                 right = max(right, childRightEdge + paddingRight() + relativeOffset);
             }
@@ -3552,7 +3572,7 @@ int RenderBlock::leftmostPosition(bool i
 
     if (hasColumns()) {
         // This only matters for RTL
-        if (!style()->isLeftToRightDirection()) {
+        if (style()->direction() == RTL) {
             ColumnInfo* colInfo = columnInfo();
             unsigned count = columnCount(colInfo);
             if (count)
@@ -4422,7 +4442,7 @@ IntRect RenderBlock::columnRectAt(Column
     int colHeight = colInfo->columnHeight();
     int colTop = borderTop() + paddingTop();
     int colGap = columnGap();
-    int colLeft = style()->isLeftToRightDirection() ? 
+    int colLeft = style()->direction() == LTR ? 
                       borderLeft() + paddingLeft() + (index * (colWidth + colGap))
                       : borderLeft() + paddingLeft() + contentWidth() - colWidth - (index * (colWidth + colGap));
     return IntRect(colLeft, colTop, colWidth, colHeight);
@@ -4464,8 +4484,8 @@ bool RenderBlock::layoutColumns(bool has
 
         if (columnCount(colInfo)) {
             IntRect lastRect = columnRectAt(colInfo, columnCount(colInfo) - 1);
-            int overflowLeft = !style()->isLeftToRightDirection() ? min(0, lastRect.x()) : 0;
-            int overflowRight = style()->isLeftToRightDirection() ? max(width(), lastRect.x() + lastRect.width()) : 0;
+            int overflowLeft = style()->direction() == RTL ? min(0, lastRect.x()) : 0;
+            int overflowRight = style()->direction() == LTR ? max(width(), lastRect.x() + lastRect.width()) : 0;
             int overflowHeight = borderTop() + paddingTop() + colInfo->columnHeight();
             
             setLogicalHeight(overflowHeight + borderBottom() + paddingBottom() + horizontalScrollbarHeight());
@@ -4711,7 +4731,7 @@ static int getBorderPaddingMargin(const 
 {
     RenderStyle* cstyle = child->style();
     int result = 0;
-    bool leftSide = (cstyle->isLeftToRightDirection()) ? !endOfInline : endOfInline;
+    bool leftSide = (cstyle->direction() == LTR) ? !endOfInline : endOfInline;
     result += getBPMWidth((leftSide ? child->marginLeft() : child->marginRight()),
                           (leftSide ? cstyle->marginLeft() :
                                       cstyle->marginRight()));
@@ -5733,7 +5753,7 @@ IntRect RenderBlock::localCaretRect(Inli
     switch (currentStyle->textAlign()) {
         case TAAUTO:
         case JUSTIFY:
-            if (!currentStyle->isLeftToRightDirection())
+            if (currentStyle->direction() == RTL)
                 alignment = alignRight;
             break;
         case LEFT:
@@ -6069,26 +6089,26 @@ int RenderBlock::marginAfterForChild(Ren
 int RenderBlock::marginStartForChild(RenderBoxModelObject* child) const
 {
     if (style()->isVerticalBlockFlow())
-        return style()->isLeftToRightDirection() ? child->marginLeft() : child->marginRight();
-    return style()->isLeftToRightDirection() ? child->marginTop() : child->marginBottom();
+        return style()->direction() == LTR ? child->marginLeft() : child->marginRight();
+    return style()->direction() == LTR ? child->marginTop() : child->marginBottom();
 }
 
 int RenderBlock::marginEndForChild(RenderBoxModelObject* child) const
 {
     if (style()->isVerticalBlockFlow())
-        return style()->isLeftToRightDirection() ? child->marginRight() : child->marginLeft();
-    return style()->isLeftToRightDirection() ? child->marginBottom() : child->marginTop();
+        return style()->direction() == LTR ? child->marginRight() : child->marginLeft();
+    return style()->direction() == LTR ? child->marginBottom() : child->marginTop();
 }
 
 void RenderBlock::setMarginStartForChild(RenderBox* child, int margin)
 {
     if (style()->isVerticalBlockFlow()) {
-        if (style()->isLeftToRightDirection())
+        if (style()->direction() == LTR)
             child->setMarginLeft(margin);
         else
             child->setMarginRight(margin);
     } else {
-        if (style()->isLeftToRightDirection())
+        if (style()->direction() == LTR)
             child->setMarginTop(margin);
         else
             child->setMarginBottom(margin);
@@ -6098,12 +6118,12 @@ void RenderBlock::setMarginStartForChild
 void RenderBlock::setMarginEndForChild(RenderBox* child, int margin)
 {
     if (style()->isVerticalBlockFlow()) {
-        if (style()->isLeftToRightDirection())
+        if (style()->direction() == LTR)
             child->setMarginRight(margin);
         else
             child->setMarginLeft(margin);
     } else {
-        if (style()->isLeftToRightDirection())
+        if (style()->direction() == LTR)
             child->setMarginBottom(margin);
         else
             child->setMarginTop(margin);
diff -Naurp WebKit-r68833/WebCore/rendering/RenderBlock.h wxwebkit/WebCore/rendering/RenderBlock.h
--- WebKit-r68833/WebCore/rendering/RenderBlock.h	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderBlock.h	2010-10-23 03:51:26.185000070 +0400
@@ -105,7 +105,7 @@ public:
     int availableLogicalWidthForLine(int position, bool firstLine) const;
     int logicalRightOffsetForLine(int position, bool firstLine) const { return logicalRightOffsetForLine(position, logicalRightOffsetForContent(), firstLine); }
     int logicalLeftOffsetForLine(int position, bool firstLine) const { return logicalLeftOffsetForLine(position, logicalLeftOffsetForContent(), firstLine); }
-
+    
     virtual int lowestPosition(bool includeOverflowInterior = true, bool includeSelf = true) const;
     virtual int rightmostPosition(bool includeOverflowInterior = true, bool includeSelf = true) const;
     virtual int leftmostPosition(bool includeOverflowInterior = true, bool includeSelf = true) const;
@@ -170,11 +170,8 @@ public:
     void setPageY(int y);
 
     // Accessors for logical width/height and margins in the containing block's block-flow direction.
-    int logicalWidthForChild(RenderBox* child) { return style()->isVerticalBlockFlow() ? child->width() : child->height(); }
     int logicalHeightForChild(RenderBox* child) { return style()->isVerticalBlockFlow() ? child->height() : child->width(); }
     int logicalTopForChild(RenderBox* child) { return style()->isVerticalBlockFlow() ? child->y() : child->x(); }
-    void setLogicalLeftForChild(RenderBox* child, int logicalLeft);
-    void setLogicalTopForChild(RenderBox* child, int logicalTop);
     int marginBeforeForChild(RenderBoxModelObject* child) const;
     int marginAfterForChild(RenderBoxModelObject* child) const;
     int marginStartForChild(RenderBoxModelObject* child) const;
@@ -237,8 +234,8 @@ protected:
     virtual void paint(PaintInfo&, int tx, int ty);
     virtual void paintObject(PaintInfo&, int tx, int ty);
 
-    int logicalRightOffsetForContent() const { return style()->isVerticalBlockFlow() ? borderLeft() + paddingLeft() + availableLogicalWidth() : borderTop() + paddingTop() + availableLogicalWidth(); }
-    int logicalLeftOffsetForContent() const { return style()->isVerticalBlockFlow() ? borderLeft() + paddingLeft() : borderTop() + paddingTop(); }
+    int logicalRightOffsetForContent() const;
+    int logicalLeftOffsetForContent() const;
     int logicalRightOffsetForLine(int position, int fixedOffset, bool applyTextIndent = true, int* logicalHeightRemaining = 0) const;
     int logicalLeftOffsetForLine(int position, int fixedOffset, bool applyTextIndent = true, int* logicalHeightRemaining = 0) const;
 
@@ -587,6 +584,7 @@ private:
     void determineLogicalLeftPositionForChild(RenderBox* child);
     void handleAfterSideOfBlock(int top, int bottom, MarginInfo&);
     void setCollapsedBottomMargin(const MarginInfo&);
+    void setLogicalTopForChild(RenderBox* child, int logicalTop);
     // End helper functions and structs used by layoutBlockChildren.
 
     // Pagination routines.
diff -Naurp WebKit-r68833/WebCore/rendering/RenderBlockLineLayout.cpp wxwebkit/WebCore/rendering/RenderBlockLineLayout.cpp
--- WebKit-r68833/WebCore/rendering/RenderBlockLineLayout.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderBlockLineLayout.cpp	2010-10-23 03:51:26.186000070 +0400
@@ -57,7 +57,7 @@ const unsigned cMaxLineDepth = 200;
 
 static int getBorderPaddingMargin(RenderBoxModelObject* child, bool endOfInline)
 {
-    bool leftSide = (child->style()->isLeftToRightDirection()) ? !endOfInline : endOfInline;
+    bool leftSide = (child->style()->direction() == LTR) ? !endOfInline : endOfInline;
     if (leftSide)
         return child->marginLeft() + child->paddingLeft() + child->borderLeft();
     return child->marginRight() + child->paddingRight() + child->borderRight();
@@ -244,7 +244,7 @@ RootInlineBox* RenderBlock::constructLin
         // Create a box for our object.
         bool isOnlyRun = (runCount == 1);
         if (runCount == 2 && !r->m_object->isListMarker())
-            isOnlyRun = (!style()->isLeftToRightDirection() ? lastRun : firstRun)->m_object->isListMarker();
+            isOnlyRun = ((style()->direction() == RTL) ? lastRun : firstRun)->m_object->isListMarker();
 
         InlineBox* box = createInlineBoxForRenderer(r->m_object, false, isOnlyRun);
         r->m_box = box;
@@ -363,7 +363,7 @@ void RenderBlock::computeInlineDirection
         case WEBKIT_LEFT:
             // The direction of the block should determine what happens with wide lines.  In
             // particular with RTL blocks, wide lines should still spill out to the left.
-            if (style()->isLeftToRightDirection()) {
+            if (style()->direction() == LTR) {
                 if (totWidth > availableWidth && trailingSpaceRun)
                     trailingSpaceRun->m_box->setLogicalWidth(max(0, trailingSpaceRun->m_box->logicalWidth() - totWidth + availableWidth));
             } else {
@@ -385,7 +385,7 @@ void RenderBlock::computeInlineDirection
         case TAAUTO:
             numSpaces = 0;
             // for right to left fall through to right aligned
-            if (style()->isLeftToRightDirection()) {
+            if (style()->direction() == LTR) {
                 if (totWidth > availableWidth && trailingSpaceRun)
                     trailingSpaceRun->m_box->setLogicalWidth(max(0, trailingSpaceRun->m_box->logicalWidth() - totWidth + availableWidth));
                 break;
@@ -395,7 +395,7 @@ void RenderBlock::computeInlineDirection
             // Wide lines spill out of the block based off direction.
             // So even if text-align is right, if direction is LTR, wide lines should overflow out of the right
             // side of the block.
-            if (style()->isLeftToRightDirection()) {
+            if (style()->direction() == LTR) {
                 if (trailingSpaceRun) {
                     totWidth -= trailingSpaceRun->m_box->logicalWidth();
                     trailingSpaceRun->m_box->setLogicalWidth(0);
@@ -418,7 +418,7 @@ void RenderBlock::computeInlineDirection
                 trailingSpaceWidth = min(trailingSpaceRun->m_box->logicalWidth(), (availableWidth - totWidth + 1) / 2);
                 trailingSpaceRun->m_box->setLogicalWidth(max(0, trailingSpaceWidth));
             }
-            if (style()->isLeftToRightDirection())
+            if (style()->direction() == LTR)
                 x += max((availableWidth - totWidth) / 2, 0);
             else
                 x += totWidth > availableWidth ? (availableWidth - totWidth) : (availableWidth - totWidth) / 2 - trailingSpaceWidth;
@@ -1039,7 +1039,7 @@ RootInlineBox* RenderBlock::determineSta
         pos = last->lineBreakPos();
         resolver.setStatus(last->lineBreakBidiStatus());
     } else {
-        bool ltr = style()->isLeftToRightDirection()
+        bool ltr = style()->direction() == LTR
     #if ENABLE(SVG)   
             || (style()->unicodeBidi() == UBNormal && isSVGText())
     #endif
@@ -1252,16 +1252,16 @@ void RenderBlock::skipTrailingWhitespace
                 // A relative positioned inline encloses us.  In this case, we also have to determine our
                 // position as though we were an inline.  Set |staticX| and |staticY| on the relative positioned
                 // inline so that we can obtain the value later.
-                toRenderInline(c)->layer()->setStaticX(style()->isLeftToRightDirection() ? logicalLeftOffsetForLine(height(), false) : logicalRightOffsetForLine(height(), false));
+                toRenderInline(c)->layer()->setStaticX(style()->direction() == LTR ? logicalLeftOffsetForLine(height(), false) : logicalRightOffsetForLine(height(), false));
                 toRenderInline(c)->layer()->setStaticY(height());
             }
     
             RenderBox* box = toRenderBox(object);
             if (box->style()->hasStaticX()) {
                 if (box->style()->isOriginalDisplayInlineType())
-                    box->layer()->setStaticX(style()->isLeftToRightDirection() ? logicalLeftOffsetForLine(height(), false) : width() - logicalRightOffsetForLine(height(), false));
+                    box->layer()->setStaticX(style()->direction() == LTR ? logicalLeftOffsetForLine(height(), false) : width() - logicalRightOffsetForLine(height(), false));
                 else
-                    box->layer()->setStaticX(style()->isLeftToRightDirection() ? borderLeft() + paddingLeft() : borderRight() + paddingRight());
+                    box->layer()->setStaticX(style()->direction() == LTR ? borderLeft() + paddingLeft() : borderRight() + paddingRight());
             }
     
             if (box->style()->hasStaticY())
@@ -1288,16 +1288,16 @@ int RenderBlock::skipLeadingWhitespace(I
                 // A relative positioned inline encloses us.  In this case, we also have to determine our
                 // position as though we were an inline.  Set |staticX| and |staticY| on the relative positioned
                 // inline so that we can obtain the value later.
-                toRenderInline(c)->layer()->setStaticX(style()->isLeftToRightDirection() ? logicalLeftOffsetForLine(height(), firstLine) : logicalRightOffsetForLine(height(), firstLine));
+                toRenderInline(c)->layer()->setStaticX(style()->direction() == LTR ? logicalLeftOffsetForLine(height(), firstLine) : logicalRightOffsetForLine(height(), firstLine));
                 toRenderInline(c)->layer()->setStaticY(height());
             }
     
             RenderBox* box = toRenderBox(object);
             if (box->style()->hasStaticX()) {
                 if (box->style()->isOriginalDisplayInlineType())
-                    box->layer()->setStaticX(style()->isLeftToRightDirection() ? logicalLeftOffsetForLine(height(), firstLine) : width() - logicalRightOffsetForLine(height(), firstLine));
+                    box->layer()->setStaticX(style()->direction() == LTR ? logicalLeftOffsetForLine(height(), firstLine) : width() - logicalRightOffsetForLine(height(), firstLine));
                 else
-                    box->layer()->setStaticX(style()->isLeftToRightDirection() ? borderLeft() + paddingLeft() : borderRight() + paddingRight());
+                    box->layer()->setStaticX(style()->direction() == LTR ? borderLeft() + paddingLeft() : borderRight() + paddingRight());
             }
     
             if (box->style()->hasStaticY())
@@ -1498,7 +1498,7 @@ InlineIterator RenderBlock::findNextLine
                 bool isInlineType = box->style()->isOriginalDisplayInlineType();
                 bool needToSetStaticX = box->style()->hasStaticX();
                 if (box->style()->hasStaticX() && !isInlineType) {
-                    box->layer()->setStaticX(o->parent()->style()->isLeftToRightDirection() ?
+                    box->layer()->setStaticX(o->parent()->style()->direction() == LTR ?
                                   borderLeft() + paddingLeft() :
                                   borderRight() + paddingRight());
                     needToSetStaticX = false;
@@ -2035,7 +2035,7 @@ void RenderBlock::checkLinesForTextOverf
     // if the right edge of a line box exceeds that.  For RTL, we use the left edge of the padding box and
     // check the left edge of the line box to see if it is less
     // Include the scrollbar for overflow blocks, which means we want to use "contentWidth()"
-    bool ltr = style()->isLeftToRightDirection();
+    bool ltr = style()->direction() == LTR;
     for (RootInlineBox* curr = firstRootBox(); curr; curr = curr->nextRootBox()) {
         int blockRightEdge = logicalRightOffsetForLine(curr->y(), curr == firstRootBox());
         int blockLeftEdge = logicalLeftOffsetForLine(curr->y(), curr == firstRootBox());
diff -Naurp WebKit-r68833/WebCore/rendering/RenderBox.cpp wxwebkit/WebCore/rendering/RenderBox.cpp
--- WebKit-r68833/WebCore/rendering/RenderBox.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderBox.cpp	2010-10-23 03:51:26.187000070 +0400
@@ -118,26 +118,26 @@ int RenderBox::marginAfter() const
 int RenderBox::marginStart() const
 {
     if (style()->isVerticalBlockFlow())
-        return style()->isLeftToRightDirection() ? m_marginLeft : m_marginRight;
-    return style()->isLeftToRightDirection() ? m_marginTop : m_marginBottom;
+        return style()->direction() == LTR ? m_marginLeft : m_marginRight;
+    return style()->direction() == LTR ? m_marginTop : m_marginBottom;
 }
 
 int RenderBox::marginEnd() const
 {
     if (style()->isVerticalBlockFlow())
-        return style()->isLeftToRightDirection() ? m_marginRight : m_marginLeft;
-    return style()->isLeftToRightDirection() ? m_marginBottom : m_marginTop;
+        return style()->direction() == LTR ? m_marginRight : m_marginLeft;
+    return style()->direction() == LTR ? m_marginBottom : m_marginTop;
 }
 
 void RenderBox::setMarginStart(int margin)
 {
     if (style()->isVerticalBlockFlow()) {
-        if (style()->isLeftToRightDirection())
+        if (style()->direction() == LTR)
             m_marginLeft = margin;
         else
             m_marginRight = margin;
     } else {
-        if (style()->isLeftToRightDirection())
+        if (style()->direction() == LTR)
             m_marginTop = margin;
         else
             m_marginBottom = margin;
@@ -147,12 +147,12 @@ void RenderBox::setMarginStart(int margi
 void RenderBox::setMarginEnd(int margin)
 {
     if (style()->isVerticalBlockFlow()) {
-        if (style()->isLeftToRightDirection())
+        if (style()->direction() == LTR)
             m_marginRight = margin;
         else
             m_marginLeft = margin;
     } else {
-        if (style()->isLeftToRightDirection())
+        if (style()->direction() == LTR)
             m_marginBottom = margin;
         else
             m_marginTop = margin;
@@ -387,7 +387,7 @@ int RenderBox::scrollWidth() const
     if (hasOverflowClip())
         return layer()->scrollWidth();
     // For objects with visible overflow, this matches IE.
-    if (style()->isLeftToRightDirection())
+    if (style()->direction() == LTR)
         return max(clientWidth(), rightmostPosition(true, false) - borderLeft());
     return clientWidth() - min(0, leftmostPosition(true, false) - borderLeft());
 }
@@ -1586,8 +1586,8 @@ void RenderBox::computeInlineDirectionMa
     } 
     
     // Case Three: The object is being pushed to the end of the containing block's available logical width.
-    bool pushToEndFromTextAlign = !marginEndLength.isAuto() && ((!containingBlockStyle->isLeftToRightDirection() && containingBlockStyle->textAlign() == WEBKIT_LEFT)
-        || (containingBlockStyle->isLeftToRightDirection() && containingBlockStyle->textAlign() == WEBKIT_RIGHT));
+    bool pushToEndFromTextAlign = !marginEndLength.isAuto() && ((containingBlockStyle->direction() == RTL && containingBlockStyle->textAlign() == WEBKIT_LEFT)
+        || (containingBlockStyle->direction() == LTR && containingBlockStyle->textAlign() == WEBKIT_RIGHT));
     if ((marginStartLength.isAuto() && childWidth < containerWidth) || pushToEndFromTextAlign) {
         containingBlock->setMarginEndForChild(this, marginEndLength.calcValue(containerWidth));
         containingBlock->setMarginStartForChild(this, containerWidth - childWidth - containingBlock->marginEndForChild(this));
@@ -1958,7 +1958,7 @@ int RenderBox::containingBlockWidthForPo
 
     int fromLeft;
     int fromRight;
-    if (containingBlock->style()->isLeftToRightDirection()) {
+    if (containingBlock->style()->direction() == LTR) {
         fromLeft = first->logicalLeft() + first->borderLogicalLeft();
         fromRight = last->logicalLeft() + last->logicalWidth() - last->borderLogicalRight();
     } else {
@@ -2300,7 +2300,7 @@ void RenderBox::computePositionedLogical
     // positioned, inline because right now, it is using the xPos
     // of the first line box when really it should use the last line box.  When
     // this is fixed elsewhere, this block should be removed.
-    if (containerBlock->isRenderInline() && !containerBlock->style()->isLeftToRightDirection()) {
+    if (containerBlock->isRenderInline() && containerBlock->style()->direction() == RTL) {
         const RenderInline* flow = toRenderInline(containerBlock);
         InlineFlowBox* firstLine = flow->firstLineBox();
         InlineFlowBox* lastLine = flow->lastLineBox();
@@ -2706,7 +2706,7 @@ void RenderBox::computePositionedLogical
     // positioned, inline containing block because right now, it is using the xPos
     // of the first line box when really it should use the last line box.  When
     // this is fixed elsewhere, this block should be removed.
-    if (containerBlock->isRenderInline() && !containerBlock->style()->isLeftToRightDirection()) {
+    if (containerBlock->isRenderInline() && containerBlock->style()->direction() == RTL) {
         const RenderInline* flow = toRenderInline(containerBlock);
         InlineFlowBox* firstLine = flow->firstLineBox();
         InlineFlowBox* lastLine = flow->lastLineBox();
@@ -2860,9 +2860,9 @@ IntRect RenderBox::localCaretRect(Inline
 
     // FIXME: What about border and padding?
     IntRect rect(x(), y(), caretWidth, height());
-    bool ltr = box ? box->isLeftToRightDirection() : style()->isLeftToRightDirection();
+    TextDirection direction = box ? box->direction() : style()->direction();
 
-    if ((!caretOffset) ^ ltr)
+    if ((!caretOffset) ^ (direction == LTR))
         rect.move(IntSize(width() - caretWidth, 0));
 
     if (box) {
diff -Naurp WebKit-r68833/WebCore/rendering/RenderBoxModelObject.cpp wxwebkit/WebCore/rendering/RenderBoxModelObject.cpp
--- WebKit-r68833/WebCore/rendering/RenderBoxModelObject.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderBoxModelObject.cpp	2010-10-23 03:51:26.189000070 +0400
@@ -324,7 +324,7 @@ int RenderBoxModelObject::relativePositi
     // call availableWidth on our containing block.
     if (!style()->left().isAuto()) {
         RenderBlock* cb = containingBlock();
-        if (!style()->right().isAuto() && !containingBlock()->style()->isLeftToRightDirection())
+        if (!style()->right().isAuto() && containingBlock()->style()->direction() == RTL)
             return -style()->right().calcValue(cb->availableWidth());
         return style()->left().calcValue(cb->availableWidth());
     }
diff -Naurp WebKit-r68833/WebCore/rendering/RenderCounter.cpp wxwebkit/WebCore/rendering/RenderCounter.cpp
--- WebKit-r68833/WebCore/rendering/RenderCounter.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderCounter.cpp	2010-10-23 03:51:26.189000070 +0400
@@ -35,7 +35,7 @@ namespace WebCore {
 
 using namespace HTMLNames;
 
-typedef HashMap<RefPtr<AtomicStringImpl>, RefPtr<CounterNode> > CounterMap;
+typedef HashMap<RefPtr<AtomicStringImpl>, CounterNode*> CounterMap;
 typedef HashMap<const RenderObject*, CounterMap*> CounterMaps;
 
 static CounterNode* makeCounterNode(RenderObject*, const AtomicString& identifier, bool alwaysCreateCounter);
@@ -235,12 +235,10 @@ static CounterNode* makeCounterNode(Rend
 {
     ASSERT(object);
 
-    if (object->m_hasCounterNodeMap) {
-        if (CounterMap* nodeMap = counterMaps().get(object)) {
-            if (CounterNode* node = nodeMap->get(identifier.impl()).get())
+    if (object->m_hasCounterNodeMap)
+        if (CounterMap* nodeMap = counterMaps().get(object))
+            if (CounterNode* node = nodeMap->get(identifier.impl()))
                 return node;
-        }
-    }
 
     bool isReset = false;
     int value = 0;
@@ -249,9 +247,9 @@ static CounterNode* makeCounterNode(Rend
 
     CounterNode* newParent = 0;
     CounterNode* newPreviousSibling = 0;
-    RefPtr<CounterNode> newNode = CounterNode::create(object, isReset, value);
+    CounterNode* newNode = new CounterNode(object, isReset, value);
     if (findPlaceForCounter(object, identifier, isReset, newParent, newPreviousSibling))
-        newParent->insertAfter(newNode.get(), newPreviousSibling, identifier);
+        newParent->insertAfter(newNode, newPreviousSibling, identifier);
     CounterMap* nodeMap;
     if (object->m_hasCounterNodeMap)
         nodeMap = counterMaps().get(object);
@@ -262,7 +260,7 @@ static CounterNode* makeCounterNode(Rend
     }
     nodeMap->set(identifier.impl(), newNode);
     if (newNode->parent() || !object->nextInPreOrder(object->parent()))
-        return newNode.get();
+        return newNode;
     // Checking if some nodes that were previously counter tree root nodes
     // should become children of this node now.
     CounterMaps& maps = counterMaps();
@@ -270,7 +268,7 @@ static CounterNode* makeCounterNode(Rend
     for (RenderObject* currentRenderer = object->nextInPreOrder(stayWithin); currentRenderer; currentRenderer = currentRenderer->nextInPreOrder(stayWithin)) {
         if (!currentRenderer->m_hasCounterNodeMap)
             continue;
-        CounterNode* currentCounter = maps.get(currentRenderer)->get(identifier.impl()).get();
+        CounterNode* currentCounter = maps.get(currentRenderer)->get(identifier.impl());
         if (!currentCounter)
             continue;
         if (currentCounter->parent()) {
@@ -284,7 +282,7 @@ static CounterNode* makeCounterNode(Rend
         if (currentRenderer->lastChild())
             currentRenderer = currentRenderer->lastChild();
     }
-    return newNode.get();
+    return newNode;
 }
 
 RenderCounter::RenderCounter(Document* node, const CounterContent& counter)
@@ -347,9 +345,9 @@ void RenderCounter::invalidate(const Ato
 static void destroyCounterNodeWithoutMapRemoval(const AtomicString& identifier, CounterNode* node)
 {
     CounterNode* previous;
-    for (RefPtr<CounterNode> child = node->lastDescendant(); child && child != node; child = previous) {
+    for (CounterNode* child = node->lastDescendant(); child && child != node; child = previous) {
         previous = child->previousInPreOrder();
-        child->parent()->removeChild(child.get(), identifier);
+        child->parent()->removeChild(child, identifier);
         ASSERT(counterMaps().get(child->renderer())->get(identifier.impl()) == child);
         counterMaps().get(child->renderer())->remove(identifier.impl());
         if (!child->renderer()->documentBeingDestroyed()) {
@@ -357,6 +355,7 @@ static void destroyCounterNodeWithoutMap
             if (children)
                 children->invalidateCounters(child->renderer(), identifier);
         }
+        delete child;
     }
     RenderObject* renderer = node->renderer();
     if (!renderer->documentBeingDestroyed()) {
@@ -365,6 +364,7 @@ static void destroyCounterNodeWithoutMap
     }
     if (CounterNode* parent = node->parent())
         parent->removeChild(node, identifier);
+    delete node;
 }
 
 void RenderCounter::destroyCounterNodes(RenderObject* renderer)
@@ -377,7 +377,7 @@ void RenderCounter::destroyCounterNodes(
     CounterMap::const_iterator end = map->end();
     for (CounterMap::const_iterator it = map->begin(); it != end; ++it) {
         AtomicString identifier(it->first.get());
-        destroyCounterNodeWithoutMapRemoval(identifier, it->second.get());
+        destroyCounterNodeWithoutMapRemoval(identifier, it->second);
     }
     maps.remove(mapsIterator);
     delete map;
@@ -392,7 +392,7 @@ void RenderCounter::destroyCounterNode(R
     CounterMap::iterator mapIterator = map->find(identifier.impl());
     if (mapIterator == map->end())
         return;
-    destroyCounterNodeWithoutMapRemoval(identifier, mapIterator->second.get());
+    destroyCounterNodeWithoutMapRemoval(identifier, mapIterator->second);
     map->remove(mapIterator);
     // We do not delete "map" here even if empty because we expect to reuse
     // it soon. In order for a renderer to lose all its counters permanently,
@@ -422,24 +422,21 @@ static void updateCounters(RenderObject*
     CounterMap* counterMap = counterMaps().get(renderer);
     ASSERT(counterMap);
     for (CounterDirectiveMap::const_iterator it = directiveMap->begin(); it != end; ++it) {
-        RefPtr<CounterNode> node = counterMap->get(it->first.get());
+        CounterNode* node = counterMap->get(it->first.get());
         if (!node) {
             makeCounterNode(renderer, AtomicString(it->first.get()), false);
             continue;
         }
         CounterNode* newParent = 0;
         CounterNode* newPreviousSibling;
-        
         findPlaceForCounter(renderer, AtomicString(it->first.get()), node->hasResetType(), newParent, newPreviousSibling);
-        if (node != counterMap->get(it->first.get()))
-            continue;
         CounterNode* parent = node->parent();
         if (newParent == parent && newPreviousSibling == node->previousSibling())
             continue;
         if (parent)
-            parent->removeChild(node.get(), it->first.get());
+            parent->removeChild(node, it->first.get());
         if (newParent)
-            newParent->insertAfter(node.get(), newPreviousSibling, it->first.get());
+            newParent->insertAfter(node, newPreviousSibling, it->first.get());
     }
 }
 
diff -Naurp WebKit-r68833/WebCore/rendering/RenderFieldset.cpp wxwebkit/WebCore/rendering/RenderFieldset.cpp
--- WebKit-r68833/WebCore/rendering/RenderFieldset.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderFieldset.cpp	2010-10-23 03:51:26.190000070 +0400
@@ -72,7 +72,7 @@ RenderObject* RenderFieldset::layoutLege
         legend->layoutIfNeeded();
 
         int xPos;
-        if (!style()->isLeftToRightDirection()) {
+        if (style()->direction() == RTL) {
             switch (legend->style()->textAlign()) {
                 case LEFT:
                     xPos = borderLeft() + paddingLeft();
diff -Naurp WebKit-r68833/WebCore/rendering/RenderFileUploadControl.cpp wxwebkit/WebCore/rendering/RenderFileUploadControl.cpp
--- WebKit-r68833/WebCore/rendering/RenderFileUploadControl.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderFileUploadControl.cpp	2010-10-23 03:51:26.190000070 +0400
@@ -213,14 +213,14 @@ void RenderFileUploadControl::paintObjec
         const String& displayedFilename = fileTextValue();
         unsigned length = displayedFilename.length();
         const UChar* string = displayedFilename.characters();
-        TextRun textRun(string, length, false, 0, 0, !style()->isLeftToRightDirection(), style()->unicodeBidi() == Override);
+        TextRun textRun(string, length, false, 0, 0, style()->direction() == RTL, style()->unicodeBidi() == Override);
         
         // Determine where the filename should be placed
         int contentLeft = tx + borderLeft() + paddingLeft();
         int buttonAndIconWidth = m_button->renderBox()->width() + afterButtonSpacing
             + (m_fileChooser->icon() ? iconWidth + iconFilenameSpacing : 0);
         int textX;
-        if (style()->isLeftToRightDirection())
+        if (style()->direction() == LTR)
             textX = contentLeft + buttonAndIconWidth;
         else
             textX = contentLeft + contentWidth() - buttonAndIconWidth - style()->font().width(textRun);
@@ -239,7 +239,7 @@ void RenderFileUploadControl::paintObjec
             // Determine where the icon should be placed
             int iconY = ty + borderTop() + paddingTop() + (contentHeight() - iconHeight) / 2;
             int iconX;
-            if (style()->isLeftToRightDirection())
+            if (style()->direction() == LTR)
                 iconX = contentLeft + m_button->renderBox()->width() + afterButtonSpacing;
             else
                 iconX = contentLeft + contentWidth() - m_button->renderBox()->width() - afterButtonSpacing - iconWidth;
diff -Naurp WebKit-r68833/WebCore/rendering/RenderFlexibleBox.cpp wxwebkit/WebCore/rendering/RenderFlexibleBox.cpp
--- WebKit-r68833/WebCore/rendering/RenderFlexibleBox.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderFlexibleBox.cpp	2010-10-23 03:51:26.191000070 +0400
@@ -39,7 +39,7 @@ public:
     FlexBoxIterator(RenderFlexibleBox* parent)
     {
         box = parent;
-        if (box->style()->boxOrient() == HORIZONTAL && !box->style()->isLeftToRightDirection())
+        if (box->style()->boxOrient() == HORIZONTAL && box->style()->direction() == RTL)
             forward = box->style()->boxDirection() != BNORMAL;
         else
             forward = box->style()->boxDirection() == BNORMAL;
@@ -417,7 +417,7 @@ void RenderFlexibleBox::layoutHorizontal
             if (child->isPositioned()) {
                 child->containingBlock()->insertPositionedObject(child);
                 if (child->style()->hasStaticX()) {
-                    if (style()->isLeftToRightDirection())
+                    if (style()->direction() == LTR)
                         child->layer()->setStaticX(xPos);
                     else child->layer()->setStaticX(width() - xPos);
                 }
@@ -575,8 +575,8 @@ void RenderFlexibleBox::layoutHorizontal
 
     RenderBlock::finishDelayUpdateScrollInfo();
 
-    if (remainingSpace > 0 && ((style()->isLeftToRightDirection() && style()->boxPack() != BSTART)
-        || (!style()->isLeftToRightDirection() && style()->boxPack() != BEND))) {
+    if (remainingSpace > 0 && ((style()->direction() == LTR && style()->boxPack() != BSTART) ||
+                               (style()->direction() == RTL && style()->boxPack() != BEND))) {
         // Children must be repositioned.
         int offset = 0;
         if (style()->boxPack() == BJUSTIFY) {
@@ -645,7 +645,7 @@ void RenderFlexibleBox::layoutVerticalBo
 {
     int xPos = borderLeft() + paddingLeft();
     int yPos = borderTop() + paddingTop();
-    if (!style()->isLeftToRightDirection())
+    if (style()->direction() == RTL)
         xPos = width() - paddingRight() - borderRight();
     int toAdd = borderBottom() + paddingBottom() + horizontalScrollbarHeight();
     bool heightSpecified = false;
@@ -688,7 +688,7 @@ void RenderFlexibleBox::layoutVerticalBo
             if (child->isPositioned()) {
                 child->containingBlock()->insertPositionedObject(child);
                 if (child->style()->hasStaticX()) {
-                    if (style()->isLeftToRightDirection())
+                    if (style()->direction() == LTR)
                         child->layer()->setStaticX(borderLeft()+paddingLeft());
                     else
                         child->layer()->setStaticX(borderRight()+paddingRight());
@@ -727,13 +727,13 @@ void RenderFlexibleBox::layoutVerticalBo
                     childX += child->marginLeft() + max(0, (contentWidth() - (child->width() + child->marginLeft() + child->marginRight()))/2);
                     break;
                 case BEND:
-                    if (!style()->isLeftToRightDirection())
+                    if (style()->direction() == RTL)
                         childX += child->marginLeft();
                     else
                         childX += contentWidth() - child->marginRight() - child->width();
                     break;
                 default: // BSTART/BSTRETCH
-                    if (style()->isLeftToRightDirection())
+                    if (style()->direction() == LTR)
                         childX += child->marginLeft();
                     else
                         childX += contentWidth() - child->marginRight() - child->width();
diff -Naurp WebKit-r68833/WebCore/rendering/RenderLayer.cpp wxwebkit/WebCore/rendering/RenderLayer.cpp
--- WebKit-r68833/WebCore/rendering/RenderLayer.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderLayer.cpp	2010-10-23 03:51:26.195000070 +0400
@@ -1960,7 +1960,7 @@ void RenderLayer::computeScrollDimension
     
     m_scrollDimensionsDirty = false;
     
-    bool ltr = renderer()->style()->isLeftToRightDirection();
+    bool ltr = renderer()->style()->direction() == LTR;
 
     int clientWidth = box->clientWidth();
     int clientHeight = box->clientHeight();
diff -Naurp WebKit-r68833/WebCore/rendering/RenderListBox.cpp wxwebkit/WebCore/rendering/RenderListBox.cpp
--- WebKit-r68833/WebCore/rendering/RenderListBox.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderListBox.cpp	2010-10-23 03:51:26.197000070 +0400
@@ -334,7 +334,7 @@ void RenderListBox::paintItemForeground(
 
     unsigned length = itemText.length();
     const UChar* string = itemText.characters();
-    TextRun textRun(string, length, 0, 0, 0, !itemStyle->isLeftToRightDirection(), itemStyle->unicodeBidi() == Override, false, false);
+    TextRun textRun(string, length, 0, 0, 0, itemStyle->direction() == RTL, itemStyle->unicodeBidi() == Override, false, false);
 
     // Draw the item text
     if (itemStyle->visibility() != HIDDEN)
diff -Naurp WebKit-r68833/WebCore/rendering/RenderListItem.cpp wxwebkit/WebCore/rendering/RenderListItem.cpp
--- WebKit-r68833/WebCore/rendering/RenderListItem.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderListItem.cpp	2010-10-23 03:51:26.197000070 +0400
@@ -261,7 +261,7 @@ void RenderListItem::positionListMarker(
         // FIXME: Inline flows in the line box hierarchy that have self-painting layers should act as cutoff points
         // and really shouldn't keep propagating overflow up.  This won't really break anything other than repainting
         // not being as tight as it could be though.
-        if (style()->isLeftToRightDirection()) {
+        if (style()->direction() == LTR) {
             int leftLineOffset = logicalLeftOffsetForLine(yOffset, logicalLeftOffsetForLine(yOffset, false), false);
             markerXPos = leftLineOffset - xOffset - paddingLeft() - borderLeft() + m_marker->marginLeft();
             m_marker->inlineBoxWrapper()->adjustPosition(markerXPos - markerOldX, 0);
@@ -326,12 +326,12 @@ String RenderListItem::markerTextWithSuf
     const String markerSuffix = m_marker->suffix();
     Vector<UChar> resultVector;
 
-    if (!m_marker->style()->isLeftToRightDirection())
+    if (m_marker->style()->direction() == RTL)
         resultVector.append(markerSuffix.characters(), markerSuffix.length());
 
     resultVector.append(markerText.characters(), markerText.length());
 
-    if (m_marker->style()->isLeftToRightDirection())
+    if (m_marker->style()->direction() == LTR)
         resultVector.append(markerSuffix.characters(), markerSuffix.length());
 
     return String::adopt(resultVector);
diff -Naurp WebKit-r68833/WebCore/rendering/RenderListMarker.cpp wxwebkit/WebCore/rendering/RenderListMarker.cpp
--- WebKit-r68833/WebCore/rendering/RenderListMarker.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderListMarker.cpp	2010-10-23 03:51:26.198000070 +0400
@@ -1257,7 +1257,7 @@ void RenderListMarker::paint(PaintInfo& 
 
     const Font& font = style()->font();
     const UChar suffix = listMarkerSuffix(type, m_listItem->value());
-    if (style()->isLeftToRightDirection()) {
+    if (style()->direction() == LTR) {
         int width = font.width(textRun);
         context->drawText(style()->font(), textRun, marker.location());
         UChar suffixSpace[2] = { suffix, ' ' };
@@ -1444,7 +1444,7 @@ void RenderListMarker::updateMargins()
 
     if (isInside()) {
         if (isImage()) {
-            if (style()->isLeftToRightDirection())
+            if (style()->direction() == LTR)
                 marginRight = cMarkerPadding;
             else
                 marginLeft = cMarkerPadding;
@@ -1452,7 +1452,7 @@ void RenderListMarker::updateMargins()
             case Disc:
             case Circle:
             case Square:
-                if (style()->isLeftToRightDirection()) {
+                if (style()->direction() == LTR) {
                     marginLeft = -1;
                     marginRight = font.ascent() - minPreferredLogicalWidth() + 1;
                 } else {
@@ -1464,7 +1464,7 @@ void RenderListMarker::updateMargins()
                 break;
         }
     } else {
-        if (style()->isLeftToRightDirection()) {
+        if (style()->direction() == LTR) {
             if (isImage())
                 marginLeft = -minPreferredLogicalWidth() - cMarkerPadding;
             else {
@@ -1532,7 +1532,7 @@ String RenderListMarker::suffix() const
 
     // If the suffix is not ' ', an extra space is needed
     if (suffix != ' ') {
-        if (style()->isLeftToRightDirection())
+        if (style()->direction() == LTR)
             resultVector.append(' ');
         else
             resultVector.prepend(' ');
diff -Naurp WebKit-r68833/WebCore/rendering/RenderMarquee.cpp wxwebkit/WebCore/rendering/RenderMarquee.cpp
--- WebKit-r68833/WebCore/rendering/RenderMarquee.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderMarquee.cpp	2010-10-23 03:51:26.198000070 +0400
@@ -110,7 +110,7 @@ int RenderMarquee::computePosition(EMarq
     ASSERT(box);
     RenderStyle* s = box->style();
     if (isHorizontal()) {
-        bool ltr = s->isLeftToRightDirection();
+        bool ltr = s->direction() == LTR;
         int clientWidth = box->clientWidth();
         int contentWidth = ltr ? box->rightmostPosition(true, false) : box->leftmostPosition(true, false);
         if (ltr)
diff -Naurp WebKit-r68833/WebCore/rendering/RenderMeter.cpp wxwebkit/WebCore/rendering/RenderMeter.cpp
--- WebKit-r68833/WebCore/rendering/RenderMeter.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderMeter.cpp	2010-10-23 03:51:26.199000070 +0400
@@ -105,7 +105,7 @@ IntRect RenderMeter::valuePartRect() con
     
     if (rect.height() <= rect.width()) {
         int width = static_cast<int>(rect.width()*valueRatio());
-        if (!style()->isLeftToRightDirection()) {
+        if (style()->direction() == RTL) {
             rect.setX(rect.x() + (rect.width() - width));
             rect.setWidth(width);
         } else
diff -Naurp WebKit-r68833/WebCore/rendering/RenderProgress.cpp wxwebkit/WebCore/rendering/RenderProgress.cpp
--- WebKit-r68833/WebCore/rendering/RenderProgress.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderProgress.cpp	2010-10-23 03:51:26.202000070 +0400
@@ -137,7 +137,7 @@ void RenderProgress::updateAnimationStat
 IntRect RenderProgress::valuePartRect() const
 {
     IntRect rect(borderLeft() + paddingLeft(), borderTop() + paddingTop(), lround((width() - borderLeft() - paddingLeft() - borderRight() - paddingRight()) * position()), height()  - borderTop() - paddingTop() - borderBottom() - paddingBottom());
-    if (!style()->isLeftToRightDirection())
+    if (style()->direction() == RTL)
         rect.setX(width() - borderRight() - paddingRight() - rect.width());
     return rect;
 }
diff -Naurp WebKit-r68833/WebCore/rendering/RenderTableCell.cpp wxwebkit/WebCore/rendering/RenderTableCell.cpp
--- WebKit-r68833/WebCore/rendering/RenderTableCell.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderTableCell.cpp	2010-10-23 03:51:26.211000070 +0400
@@ -237,7 +237,7 @@ IntRect RenderTableCell::clippedOverflow
     if (!table()->collapseBorders() || table()->needsSectionRecalc())
         return RenderBlock::clippedOverflowRectForRepaint(repaintContainer);
 
-    bool rtl = !table()->style()->isLeftToRightDirection();
+    bool rtl = table()->style()->direction() == RTL;
     int outlineSize = style()->outlineSize();
     int left = max(borderHalfLeft(true), outlineSize);
     int right = max(borderHalfRight(true), outlineSize);
@@ -714,7 +714,7 @@ int RenderTableCell::borderAfter() const
 
 int RenderTableCell::borderHalfLeft(bool outer) const
 {
-    CollapsedBorderValue border = collapsedLeftBorder(!table()->style()->isLeftToRightDirection());
+    CollapsedBorderValue border = collapsedLeftBorder(table()->style()->direction() == RTL);
     if (border.exists())
         return (border.width() + (outer ? 0 : 1)) / 2; // Give the extra pixel to top and left.
     return 0;
@@ -722,7 +722,7 @@ int RenderTableCell::borderHalfLeft(bool
     
 int RenderTableCell::borderHalfRight(bool outer) const
 {
-    CollapsedBorderValue border = collapsedRightBorder(!table()->style()->isLeftToRightDirection());
+    CollapsedBorderValue border = collapsedRightBorder(table()->style()->direction() == RTL);
     if (border.exists())
         return (border.width() + (outer ? 1 : 0)) / 2;
     return 0;
@@ -834,7 +834,7 @@ static void addBorderStyle(RenderTableCe
 
 void RenderTableCell::collectBorderStyles(CollapsedBorderStyles& borderStyles) const
 {
-    bool rtl = !table()->style()->isLeftToRightDirection();
+    bool rtl = table()->style()->direction() == RTL;
     addBorderStyle(borderStyles, collapsedLeftBorder(rtl));
     addBorderStyle(borderStyles, collapsedRightBorder(rtl));
     addBorderStyle(borderStyles, collapsedTopBorder());
@@ -861,7 +861,7 @@ void RenderTableCell::paintCollapsedBord
     if (!table()->currentBorderStyle())
         return;
     
-    bool rtl = !table()->style()->isLeftToRightDirection();
+    bool rtl = table()->style()->direction() == RTL;
     CollapsedBorderValue leftVal = collapsedLeftBorder(rtl);
     CollapsedBorderValue rightVal = collapsedRightBorder(rtl);
     CollapsedBorderValue topVal = collapsedTopBorder();
diff -Naurp WebKit-r68833/WebCore/rendering/RenderTable.cpp wxwebkit/WebCore/rendering/RenderTable.cpp
--- WebKit-r68833/WebCore/rendering/RenderTable.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderTable.cpp	2010-10-23 03:51:26.211000070 +0400
@@ -732,7 +732,7 @@ int RenderTable::calcBorderLeft() const
         if (tb.style() > BHIDDEN)
             borderWidth = tb.width();
 
-        int leftmostColumn = !style()->isLeftToRightDirection() ? numEffCols() - 1 : 0;
+        int leftmostColumn = style()->direction() == RTL ? numEffCols() - 1 : 0;
         RenderTableCol* colGroup = colElement(leftmostColumn);
         if (colGroup) {
             const BorderValue& gb = style()->borderLeft();
@@ -791,7 +791,7 @@ int RenderTable::calcBorderRight() const
         if (tb.style() > BHIDDEN)
             borderWidth = tb.width();
 
-        int rightmostColumn = !style()->isLeftToRightDirection() ? 0 : numEffCols() - 1;
+        int rightmostColumn = style()->direction() == RTL ? 0 : numEffCols() - 1;
         RenderTableCol* colGroup = colElement(rightmostColumn);
         if (colGroup) {
             const BorderValue& gb = style()->borderRight();
diff -Naurp WebKit-r68833/WebCore/rendering/RenderTableSection.cpp wxwebkit/WebCore/rendering/RenderTableSection.cpp
--- WebKit-r68833/WebCore/rendering/RenderTableSection.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderTableSection.cpp	2010-10-23 03:51:26.212000070 +0400
@@ -605,7 +605,7 @@ int RenderTableSection::layoutRows(int t
             
             IntRect oldCellRect(cell->x(), cell->y() , cell->width(), cell->height());
             
-            if (!style()->isLeftToRightDirection())
+            if (style()->direction() == RTL)
                 cell->setLocation(table()->columnPositions()[nEffCols] - table()->columnPositions()[table()->colToEffCol(cell->col() + cell->colSpan())] + hspacing, m_rowPos[rindx]);
             else
                 cell->setLocation(table()->columnPositions()[c] + hspacing, m_rowPos[rindx]);
@@ -911,7 +911,7 @@ int RenderTableSection::calcOuterBorderR
 
 void RenderTableSection::recalcOuterBorder()
 {
-    bool rtl = !table()->style()->isLeftToRightDirection();
+    bool rtl = table()->style()->direction() == RTL;
     m_outerBorderTop = calcOuterBorderTop();
     m_outerBorderBottom = calcOuterBorderBottom();
     m_outerBorderLeft = calcOuterBorderLeft(rtl);
@@ -1043,7 +1043,7 @@ void RenderTableSection::paintObject(Pai
     unsigned startcol = 0;
     unsigned endcol = totalCols;
     // FIXME: Implement RTL.
-    if (!m_hasOverflowingCell && style()->isLeftToRightDirection()) {
+    if (!m_hasOverflowingCell && style()->direction() == LTR) {
         int relativeX = x - tx;
         int left = relativeX - os;
         Vector<int>& columnPos = table()->columnPositions();
@@ -1223,7 +1223,7 @@ bool RenderTableSection::nodeAtPoint(con
         --leftrow;
 
     Vector<int>& columnPos = table()->columnPositions();
-    bool rtl = !style()->isLeftToRightDirection();
+    bool rtl = style()->direction() == RTL;
     int relativeX = xPos - tx;
     if (rtl)
         relativeX = columnPos[columnPos.size() - 1] - relativeX;
diff -Naurp WebKit-r68833/WebCore/rendering/RenderTextControlSingleLine.cpp wxwebkit/WebCore/rendering/RenderTextControlSingleLine.cpp
--- WebKit-r68833/WebCore/rendering/RenderTextControlSingleLine.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderTextControlSingleLine.cpp	2010-10-23 03:51:26.214000070 +0400
@@ -368,7 +368,7 @@ void RenderTextControlSingleLine::forwar
     if (event->type() == eventNames().blurEvent) {
         if (innerTextRenderer) {
             if (RenderLayer* innerLayer = innerTextRenderer->layer())
-                innerLayer->scrollToOffset(!style()->isLeftToRightDirection() ? innerLayer->scrollWidth() : 0, 0);
+                innerLayer->scrollToOffset(style()->direction() == RTL ? innerLayer->scrollWidth() : 0, 0);
         }
 
         capsLockStateMayHaveChanged();
diff -Naurp WebKit-r68833/WebCore/rendering/RenderText.cpp wxwebkit/WebCore/rendering/RenderText.cpp
--- WebKit-r68833/WebCore/rendering/RenderText.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderText.cpp	2010-10-23 03:51:26.213000070 +0400
@@ -511,7 +511,7 @@ IntRect RenderText::localCaretRect(Inlin
     switch (cbStyle->textAlign()) {
     case TAAUTO:
     case JUSTIFY:
-        rightAligned = !cbStyle->isLeftToRightDirection();
+        rightAligned = cbStyle->direction() == RTL;
         break;
     case RIGHT:
     case WEBKIT_RIGHT:
@@ -1224,7 +1224,7 @@ void RenderText::positionLineBox(InlineB
         return;
     }
 
-    m_containsReversedText |= !s->isLeftToRightDirection();
+    m_containsReversedText |= s->direction() == RTL;
 }
 
 unsigned RenderText::width(unsigned from, unsigned len, int xPos, bool firstLine, HashSet<const SimpleFontData*>* fallbackFonts, GlyphOverflow* glyphOverflow) const
diff -Naurp WebKit-r68833/WebCore/rendering/RenderThemeMac.mm wxwebkit/WebCore/rendering/RenderThemeMac.mm
--- WebKit-r68833/WebCore/rendering/RenderThemeMac.mm	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderThemeMac.mm	2010-10-23 03:51:26.218000070 +0400
@@ -905,7 +905,7 @@ NSLevelIndicatorCell* RenderThemeMac::le
     }
 
     [cell setLevelIndicatorStyle:levelIndicatorStyleFor(style->appearance())];
-    [cell setBaseWritingDirection:style->isLeftToRightDirection() ? NSWritingDirectionLeftToRight : NSWritingDirectionRightToLeft];
+    [cell setBaseWritingDirection:style->direction() == LTR ? NSWritingDirectionLeftToRight : NSWritingDirectionRightToLeft];
     [cell setMinValue:element->min()];
     [cell setMaxValue:element->max()];
     RetainPtr<NSNumber> valueObject = [NSNumber numberWithDouble:value];
@@ -959,7 +959,7 @@ bool RenderThemeMac::paintProgressBar(Re
 
     paintInfo.context->save();
 
-    if (!renderProgress->style()->isLeftToRightDirection()) {
+    if (renderProgress->style()->direction() == RTL) {
         paintInfo.context->translate(2 * rect.x() + rect.width(), 0);
         paintInfo.context->scale(FloatSize(-1, 1));
     }
diff -Naurp WebKit-r68833/WebCore/rendering/RenderTreeAsText.cpp wxwebkit/WebCore/rendering/RenderTreeAsText.cpp
--- WebKit-r68833/WebCore/rendering/RenderTreeAsText.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/RenderTreeAsText.cpp	2010-10-23 03:51:26.234000073 +0400
@@ -440,8 +440,8 @@ static void writeTextRun(TextStream& ts,
     if (o.containingBlock()->isTableCell())
         y -= toRenderTableCell(o.containingBlock())->intrinsicPaddingBefore();
     ts << "text run at (" << run.m_x << "," << y << ") width " << run.m_logicalWidth;
-    if (!run.isLeftToRightDirection() || run.m_dirOverride) {
-        ts << (!run.isLeftToRightDirection() ? " RTL" : " LTR");
+    if (run.direction() == RTL || run.m_dirOverride) {
+        ts << (run.direction() == RTL ? " RTL" : " LTR");
         if (run.m_dirOverride)
             ts << " override";
     }
diff -Naurp WebKit-r68833/WebCore/rendering/style/RenderStyle.cpp wxwebkit/WebCore/rendering/style/RenderStyle.cpp
--- WebKit-r68833/WebCore/rendering/style/RenderStyle.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/style/RenderStyle.cpp	2010-10-23 03:51:26.245000070 +0400
@@ -1141,15 +1141,15 @@ unsigned short RenderStyle::borderAfterW
 unsigned short RenderStyle::borderStartWidth() const
 {
     if (isVerticalBlockFlow())
-        return isLeftToRightDirection() ? borderLeftWidth() : borderRightWidth();
-    return isLeftToRightDirection() ? borderTopWidth() : borderBottomWidth();
+        return direction() == LTR ? borderLeftWidth() : borderRightWidth();
+    return direction() == LTR ? borderTopWidth() : borderBottomWidth();
 }
 
 unsigned short RenderStyle::borderEndWidth() const
 {
     if (isVerticalBlockFlow())
-        return isLeftToRightDirection() ? borderRightWidth() : borderLeftWidth();
-    return isLeftToRightDirection() ? borderBottomWidth() : borderTopWidth();
+        return direction() == LTR ? borderRightWidth() : borderLeftWidth();
+    return direction() == LTR ? borderBottomWidth() : borderTopWidth();
 }
     
 Length RenderStyle::marginBefore() const
@@ -1219,29 +1219,29 @@ Length RenderStyle::marginAfterUsing(con
 Length RenderStyle::marginStart() const
 {
     if (isVerticalBlockFlow())
-        return isLeftToRightDirection() ? marginLeft() : marginRight();
-    return isLeftToRightDirection() ? marginTop() : marginBottom();
+        return direction() == LTR ? marginLeft() : marginRight();
+    return direction() == LTR ? marginTop() : marginBottom();
 }
 
 Length RenderStyle::marginEnd() const
 {
     if (isVerticalBlockFlow())
-        return isLeftToRightDirection() ? marginRight() : marginLeft();
-    return isLeftToRightDirection() ? marginBottom() : marginTop();
+        return direction() == LTR ? marginRight() : marginLeft();
+    return direction() == LTR ? marginBottom() : marginTop();
 }
     
 Length RenderStyle::marginStartUsing(const RenderStyle* otherStyle) const
 {
     if (otherStyle->isVerticalBlockFlow())
-        return otherStyle->isLeftToRightDirection() ? marginLeft() : marginRight();
-    return otherStyle->isLeftToRightDirection() ? marginTop() : marginBottom();
+        return otherStyle->direction() == LTR ? marginLeft() : marginRight();
+    return otherStyle->direction() == LTR ? marginTop() : marginBottom();
 }
 
 Length RenderStyle::marginEndUsing(const RenderStyle* otherStyle) const
 {
     if (otherStyle->isVerticalBlockFlow())
-        return otherStyle->isLeftToRightDirection() ? marginRight() : marginLeft();
-    return otherStyle->isLeftToRightDirection() ? marginBottom() : marginTop();
+        return otherStyle->direction() == LTR ? marginRight() : marginLeft();
+    return otherStyle->direction() == LTR ? marginBottom() : marginTop();
 }
 
 Length RenderStyle::paddingBefore() const
@@ -1279,15 +1279,15 @@ Length RenderStyle::paddingAfter() const
 Length RenderStyle::paddingStart() const
 {
     if (isVerticalBlockFlow())
-        return isLeftToRightDirection() ? paddingLeft() : paddingRight();
-    return isLeftToRightDirection() ? paddingTop() : paddingBottom();
+        return direction() == LTR ? paddingLeft() : paddingRight();
+    return direction() == LTR ? paddingTop() : paddingBottom();
 }
 
 Length RenderStyle::paddingEnd() const
 {
     if (isVerticalBlockFlow())
-        return isLeftToRightDirection() ? paddingRight() : paddingLeft();
-    return isLeftToRightDirection() ? paddingBottom() : paddingTop();
+        return direction() == LTR ? paddingRight() : paddingLeft();
+    return direction() == LTR ? paddingBottom() : paddingTop();
 }
 
 } // namespace WebCore
diff -Naurp WebKit-r68833/WebCore/rendering/style/RenderStyle.h wxwebkit/WebCore/rendering/style/RenderStyle.h
--- WebKit-r68833/WebCore/rendering/style/RenderStyle.h	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/style/RenderStyle.h	2010-10-23 03:51:26.246000070 +0400
@@ -476,8 +476,6 @@ public:
     float effectiveZoom() const { return rareInheritedData->m_effectiveZoom; }
 
     TextDirection direction() const { return static_cast<TextDirection>(inherited_flags._direction); }
-    bool isLeftToRightDirection() const { return direction() == LTR; }
-
     Length lineHeight() const { return inherited->line_height; }
     int computedLineHeight() const
     {
diff -Naurp WebKit-r68833/WebCore/rendering/SVGInlineTextBox.cpp wxwebkit/WebCore/rendering/SVGInlineTextBox.cpp
--- WebKit-r68833/WebCore/rendering/SVGInlineTextBox.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/SVGInlineTextBox.cpp	2010-10-23 03:51:26.238000070 +0400
@@ -67,7 +67,7 @@ void SVGInlineTextBox::measureCharacter(
 {
     ASSERT(style);
 
-    int offset = !isLeftToRightDirection() ? end() - position : start() + position;
+    int offset = direction() == RTL ? end() - position : start() + position;
     int extraCharsAvailable = len() - position - 1;
     const UChar* characters = textRenderer()->characters();
 
@@ -647,6 +647,7 @@ void SVGInlineTextBox::buildLayoutInform
     const Font& font = style->font();
     const UChar* characters = textRenderer->characters();
 
+    TextDirection textDirection = direction();
     unsigned startPosition = start();
     unsigned endPosition = end();
     unsigned length = len();
@@ -716,10 +717,10 @@ void SVGInlineTextBox::buildLayoutInform
         // Take letter & word spacing and kerning into account
         float spacing = font.letterSpacing() + calculateCSSKerning(lengthContext, style);
 
-        const UChar* currentCharacter = characters + (!isLeftToRightDirection() ? endPosition - i : startPosition + i);
+        const UChar* currentCharacter = characters + (textDirection == RTL ? endPosition - i : startPosition + i);
         const UChar* lastCharacter = 0;
 
-        if (!isLeftToRightDirection()) {
+        if (textDirection == RTL) {
             if (i < endPosition)
                 lastCharacter = characters + endPosition - i +  1;
         } else {
diff -Naurp WebKit-r68833/WebCore/rendering/SVGRenderTreeAsText.cpp wxwebkit/WebCore/rendering/SVGRenderTreeAsText.cpp
--- WebKit-r68833/WebCore/rendering/SVGRenderTreeAsText.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/SVGRenderTreeAsText.cpp	2010-10-23 03:51:26.239000070 +0400
@@ -484,8 +484,8 @@ static inline void writeSVGInlineTextBox
             else
                 ts << " width " << cummulatedWidthOfInlineBoxCharacterRange(range);
 
-            if (!textBox->isLeftToRightDirection() || textBox->m_dirOverride) {
-                ts << (!textBox->isLeftToRightDirection() ? " RTL" : " LTR");
+            if (textBox->direction() == RTL || textBox->m_dirOverride) {
+                ts << (textBox->direction() == RTL ? " RTL" : " LTR");
 
                 if (textBox->m_dirOverride)
                     ts << " override";
diff -Naurp WebKit-r68833/WebCore/rendering/SVGTextLayoutUtilities.cpp wxwebkit/WebCore/rendering/SVGTextLayoutUtilities.cpp
--- WebKit-r68833/WebCore/rendering/SVGTextLayoutUtilities.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/rendering/SVGTextLayoutUtilities.cpp	2010-10-23 03:51:26.241000070 +0400
@@ -300,7 +300,7 @@ TextRun svgTextRunForInlineTextBox(const
                 , false /* allowTabs */
                 , 0 /* xPos, only relevant with allowTabs=true */
                 , 0 /* padding, only relevant for justified text, not relevant for SVG */
-                , !textBox->isLeftToRightDirection()
+                , textBox->direction() == RTL
                 , textBox->m_dirOverride || style->visuallyOrdered() /* directionalOverride */);
 
 #if ENABLE(SVG_FONTS)
diff -Naurp WebKit-r68833/WebCore/wml/WMLTableElement.cpp wxwebkit/WebCore/wml/WMLTableElement.cpp
--- WebKit-r68833/WebCore/wml/WMLTableElement.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebCore/wml/WMLTableElement.cpp	2010-10-23 03:51:26.341000069 +0400
@@ -231,7 +231,7 @@ void WMLTableElement::alignCells(Vector<
     bool rtl = false;
     if (RenderObject* renderer = rowElement->renderer()) {
         if (RenderStyle* style = renderer->style())
-            rtl = !style->isLeftToRightDirection();
+            rtl = style->direction() == RTL;
     }
 
     rowElement->setAttribute(HTMLNames::alignAttr, rtl ? "right" : "left");
diff -Naurp WebKit-r68833/WebKit/chromium/public/WebDragData.h wxwebkit/WebKit/chromium/public/WebDragData.h
--- WebKit-r68833/WebKit/chromium/public/WebDragData.h	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKit/chromium/public/WebDragData.h	2010-10-23 03:51:26.368000069 +0400
@@ -66,7 +66,7 @@ public:
 
     bool isNull() const { return !m_private; }
 
-    WEBKIT_API WebString url() const;
+    WEBKIT_API WebURL url() const;
     WEBKIT_API void setURL(const WebURL&);
 
     WEBKIT_API WebString urlTitle() const;
diff -Naurp WebKit-r68833/WebKit/chromium/public/WebHTTPBody.h wxwebkit/WebKit/chromium/public/WebHTTPBody.h
--- WebKit-r68833/WebKit/chromium/public/WebHTTPBody.h	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKit/chromium/public/WebHTTPBody.h	2010-10-23 03:51:26.372000069 +0400
@@ -32,6 +32,7 @@
 #define WebHTTPBody_h
 
 #include "WebData.h"
+#include "WebFileInfo.h"
 #include "WebNonCopyable.h"
 #include "WebString.h"
 #include "WebURL.h"
@@ -53,6 +54,8 @@ public:
         WebString filePath;
         long long fileStart;
         long long fileLength; // -1 means to the end of the file.
+        // FIXME: remove this field once all users of Element have been switched to use 'modificationTime'.
+        WebFileInfo fileInfo;
         double modificationTime;
         WebURL blobURL;
     };
@@ -85,6 +88,8 @@ public:
     WEBKIT_API void appendFile(const WebString&);
     // Passing -1 to fileLength means to the end of the file.
     WEBKIT_API void appendFileRange(const WebString&, long long fileStart, long long fileLength, double modificationTime);
+    // FIXME: Remove this method once all callers have been switched to use the method above.
+    WEBKIT_API void appendFileRange(const WebString&, long long fileStart, long long fileLength, const WebFileInfo&);
     WEBKIT_API void appendBlob(const WebURL&);
 
     // Identifies a particular form submission instance.  A value of 0 is
diff -Naurp WebKit-r68833/WebKit/chromium/src/WebDragData.cpp wxwebkit/WebKit/chromium/src/WebDragData.cpp
--- WebKit-r68833/WebKit/chromium/src/WebDragData.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKit/chromium/src/WebDragData.cpp	2010-10-23 03:51:26.398000069 +0400
@@ -32,7 +32,6 @@
 #include "WebDragData.h"
 
 #include "ChromiumDataObject.h"
-#include "ClipboardMimeTypes.h"
 #include "WebData.h"
 #include "WebString.h"
 #include "WebURL.h"
@@ -49,7 +48,7 @@ class WebDragDataPrivate : public Chromi
 
 void WebDragData::initialize()
 {
-    assign(static_cast<WebDragDataPrivate*>(ChromiumDataObject::create(Clipboard::DragAndDrop).releaseRef()));
+    assign(static_cast<WebDragDataPrivate*>(ChromiumDataObject::create().releaseRef()));
 }
 
 void WebDragData::reset()
@@ -65,144 +64,137 @@ void WebDragData::assign(const WebDragDa
     assign(p);
 }
 
-WebString WebDragData::url() const
+WebURL WebDragData::url() const
 {
     ASSERT(!isNull());
-    bool ignoredSuccess;
-    return m_private->getData(mimeTypeURL, ignoredSuccess);
+    return m_private->getURL();
 }
 
 void WebDragData::setURL(const WebURL& url)
 {
     ensureMutable();
-    m_private->setData(mimeTypeURL, KURL(url).string());
+    m_private->setURL(url);
 }
 
 WebString WebDragData::urlTitle() const
 {
     ASSERT(!isNull());
-    return m_private->urlTitle();
+    return m_private->urlTitle;
 }
 
 void WebDragData::setURLTitle(const WebString& urlTitle)
 {
     ensureMutable();
-    m_private->setUrlTitle(urlTitle);
+    m_private->urlTitle = urlTitle;
 }
 
 WebString WebDragData::downloadMetadata() const
 {
     ASSERT(!isNull());
-    bool ignoredSuccess;
-    return m_private->getData(mimeTypeDownloadURL, ignoredSuccess);
+    return m_private->downloadMetadata;
 }
 
 void WebDragData::setDownloadMetadata(const WebString& downloadMetadata)
 {
     ensureMutable();
-    m_private->setData(mimeTypeDownloadURL, downloadMetadata);
+    m_private->downloadMetadata = downloadMetadata;
 }
 
 WebString WebDragData::fileExtension() const
 {
     ASSERT(!isNull());
-    return m_private->fileExtension();
+    return m_private->fileExtension;
 }
 
 void WebDragData::setFileExtension(const WebString& fileExtension)
 {
     ensureMutable();
-    m_private->setFileExtension(fileExtension);
+    m_private->fileExtension = fileExtension;
 }
 
 bool WebDragData::hasFileNames() const
 {
     ASSERT(!isNull());
-    return m_private->containsFilenames();
+    return !m_private->filenames.isEmpty();
 }
 
 void WebDragData::fileNames(WebVector<WebString>& fileNames) const
 {
     ASSERT(!isNull());
-    fileNames = m_private->filenames();
+    fileNames = m_private->filenames;
 }
 
 void WebDragData::setFileNames(const WebVector<WebString>& fileNames)
 {
     ensureMutable();
-    Vector<String> fileNamesCopy;
-    fileNamesCopy.append(fileNames.data(), fileNames.size());
-    m_private->setFilenames(fileNamesCopy);
+    m_private->filenames.clear();
+    m_private->filenames.append(fileNames.data(), fileNames.size());
 }
 
 void WebDragData::appendToFileNames(const WebString& fileName)
 {
     ensureMutable();
-    Vector<String> fileNames = m_private->filenames();
-    fileNames.append(fileName);
-    m_private->setFilenames(fileNames);
+    m_private->filenames.append(fileName);
 }
 
 WebString WebDragData::plainText() const
 {
     ASSERT(!isNull());
-    bool ignoredSuccess;
-    return m_private->getData(mimeTypeTextPlain, ignoredSuccess);
+    return m_private->plainText;
 }
 
 void WebDragData::setPlainText(const WebString& plainText)
 {
     ensureMutable();
-    m_private->setData(mimeTypeTextPlain, plainText);
+    m_private->plainText = plainText;
 }
 
 WebString WebDragData::htmlText() const
 {
     ASSERT(!isNull());
-    bool ignoredSuccess;
-    return m_private->getData(mimeTypeTextHTML, ignoredSuccess);
+    return m_private->textHtml;
 }
 
 void WebDragData::setHTMLText(const WebString& htmlText)
 {
     ensureMutable();
-    m_private->setData(mimeTypeTextHTML, htmlText);
+    m_private->textHtml = htmlText;
 }
 
 WebURL WebDragData::htmlBaseURL() const
 {
     ASSERT(!isNull());
-    return m_private->htmlBaseUrl();
+    return m_private->htmlBaseUrl;
 }
 
 void WebDragData::setHTMLBaseURL(const WebURL& htmlBaseURL)
 {
     ensureMutable();
-    m_private->setHtmlBaseUrl(htmlBaseURL);
+    m_private->htmlBaseUrl = htmlBaseURL;
 }
 
 WebString WebDragData::fileContentFileName() const
 {
     ASSERT(!isNull());
-    return m_private->fileContentFilename();
+    return m_private->fileContentFilename;
 }
 
 void WebDragData::setFileContentFileName(const WebString& fileName)
 {
     ensureMutable();
-    m_private->setFileContentFilename(fileName);
+    m_private->fileContentFilename = fileName;
 }
 
 WebData WebDragData::fileContent() const
 {
     ASSERT(!isNull());
-    return WebData(m_private->fileContent());
+    return WebData(m_private->fileContent);
 }
 
 void WebDragData::setFileContent(const WebData& fileContent)
 {
     ensureMutable();
-    m_private->setFileContent(fileContent);
+    m_private->fileContent = fileContent;
 }
 
 WebDragData::WebDragData(const WTF::PassRefPtr<WebCore::ChromiumDataObject>& data)
diff -Naurp WebKit-r68833/WebKit/chromium/src/WebHTTPBody.cpp wxwebkit/WebKit/chromium/src/WebHTTPBody.cpp
--- WebKit-r68833/WebKit/chromium/src/WebHTTPBody.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKit/chromium/src/WebHTTPBody.cpp	2010-10-23 03:51:26.402000069 +0400
@@ -32,6 +32,7 @@
 #include "WebHTTPBody.h"
 
 #include "FormData.h"
+#include "WebFileInfo.h"
 
 using namespace WebCore;
 
@@ -77,6 +78,8 @@ bool WebHTTPBody::elementAt(size_t index
     result.filePath.reset();
     result.fileStart = 0;
     result.fileLength = 0;
+    // FIXME: remove this line once all users of Element have been switched to use 'modificationTime'.
+    result.fileInfo.modificationTime = 0.0;
     result.modificationTime = 0.0;
     result.blobURL = KURL();
 
@@ -91,6 +94,8 @@ bool WebHTTPBody::elementAt(size_t index
 #if ENABLE(BLOB)
         result.fileStart = element.m_fileStart;
         result.fileLength = element.m_fileLength;
+        // FIXME: remove this line once all users of Element have been switched to use 'modificationTime'.
+        result.fileInfo.modificationTime = element.m_expectedFileModificationTime;
         result.modificationTime = element.m_expectedFileModificationTime;
 #endif
         break;
@@ -130,6 +135,12 @@ void WebHTTPBody::appendFileRange(const 
 #endif
 }
 
+// FIXME: Remove this method once all callers have been switched to use the method above.
+void WebHTTPBody::appendFileRange(const WebString& filePath, long long fileStart, long long fileLength, const WebFileInfo& fileInfo)
+{
+    return appendFileRange(filePath, fileStart, fileLength, fileInfo.modificationTime);
+}
+
 void WebHTTPBody::appendBlob(const WebURL& blobURL)
 {
 #if ENABLE(BLOB)
diff -Naurp WebKit-r68833/WebKit/chromium/tests/KURLTest.cpp wxwebkit/WebKit/chromium/tests/KURLTest.cpp
--- WebKit-r68833/WebKit/chromium/tests/KURLTest.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKit/chromium/tests/KURLTest.cpp	2010-10-23 03:51:26.420000069 +0400
@@ -37,16 +37,13 @@
 
 #include "KURL.h"
 
-namespace WTF {
+namespace {
+
 // Output stream operator so gTest's macros work with WebCore strings.
-std::ostream& operator<<(std::ostream& out, const String& str)
+std::ostream& operator<<(std::ostream& out, const WTF::String& str)
 {
     return str.isEmpty() ? out : out << str.utf8().data();
 }
-} // namespace WTF
-
-namespace {
-
 
 struct ComponentCase {
     const char* url;
diff -Naurp WebKit-r68833/WebKit/mac/DOM/WebDOMOperations.mm wxwebkit/WebKit/mac/DOM/WebDOMOperations.mm
--- WebKit-r68833/WebKit/mac/DOM/WebDOMOperations.mm	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKit/mac/DOM/WebDOMOperations.mm	2010-10-23 03:51:26.510000071 +0400
@@ -136,16 +136,19 @@ using namespace JSC;
 
 @implementation DOMDocument (WebDOMDocumentOperationsInternal)
 
-- (DOMRange *)_documentRange
+/* This doesn't appear to be used by anyone.  We should consider removing this. */
+- (DOMRange *)_createRangeWithNode:(DOMNode *)node
 {
     DOMRange *range = [self createRange];
-
-    if (DOMNode* documentElement = [self documentElement])
-        [range selectNode:documentElement];
-
+    [range selectNode:node];
     return range;
 }
 
+- (DOMRange *)_documentRange
+{
+    return [self _createRangeWithNode:[self documentElement]];
+}
+
 @end
 
 @implementation DOMDocument (WebDOMDocumentOperationsPrivate)
diff -Naurp WebKit-r68833/WebKit/qt/tests/qwebview/.gitignore wxwebkit/WebKit/qt/tests/qwebview/.gitignore
--- WebKit-r68833/WebKit/qt/tests/qwebview/.gitignore	1970-01-01 03:00:00.000000000 +0300
+++ wxwebkit/WebKit/qt/tests/qwebview/.gitignore	2010-10-23 03:51:26.609000071 +0400
@@ -0,0 +1 @@
+qwebview
diff -Naurp WebKit-r68833/WebKit/qt/WebCoreSupport/DumpRenderTreeSupportQt.cpp wxwebkit/WebKit/qt/WebCoreSupport/DumpRenderTreeSupportQt.cpp
--- WebKit-r68833/WebKit/qt/WebCoreSupport/DumpRenderTreeSupportQt.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKit/qt/WebCoreSupport/DumpRenderTreeSupportQt.cpp	2010-10-23 03:51:26.582000071 +0400
@@ -764,15 +764,6 @@ void DumpRenderTreeSupportQt::simulateDe
 #endif
 }
 
-QString DumpRenderTreeSupportQt::plainText(const QVariant& range)
-{
-    QMap<QString, QVariant> map = range.toMap();
-    QVariant startContainer  = map.value("startContainer");
-    map = startContainer.toMap();
-
-    return map.value("innerText").toString();
-}
-
 // Provide a backward compatibility with previously exported private symbols as of QtWebKit 4.6 release
 
 void QWEBKIT_EXPORT qt_resumeActiveDOMObjects(QWebFrame* frame)
diff -Naurp WebKit-r68833/WebKit/qt/WebCoreSupport/DumpRenderTreeSupportQt.h wxwebkit/WebKit/qt/WebCoreSupport/DumpRenderTreeSupportQt.h
--- WebKit-r68833/WebKit/qt/WebCoreSupport/DumpRenderTreeSupportQt.h	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKit/qt/WebCoreSupport/DumpRenderTreeSupportQt.h	2010-10-23 03:51:26.582000071 +0400
@@ -98,7 +98,6 @@ public:
 
     static QString markerTextForListItem(const QWebElement& listItem);
     static QVariantMap computedStyleIncludingVisitedInfo(const QWebElement& element);
-    static QString plainText(const QVariant& rng);
 
     static void dumpFrameLoader(bool b);
     static void dumpResourceLoadCallbacks(bool b);
diff -Naurp WebKit-r68833/WebKit2/Scripts/webkit2/messages.py wxwebkit/WebKit2/Scripts/webkit2/messages.py
--- WebKit-r68833/WebKit2/Scripts/webkit2/messages.py	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKit2/Scripts/webkit2/messages.py	2010-10-23 03:51:26.692000071 +0400
@@ -198,21 +198,10 @@ def message_to_struct_declaration(messag
     return surround_in_condition(''.join(result), message.condition)
 
 
-def struct_or_class(namespace, type):
-    structs = frozenset([
-        'WebKit::WebPreferencesStore',
-    ])
-
-    qualified_name = '%s::%s' % (namespace, type)
-    if qualified_name in structs:
-        return 'struct %s' % type
-
-    return 'class %s' % type
-
 def forward_declarations_for_namespace(namespace, types):
     result = []
     result.append('namespace %s {\n' % namespace)
-    result += ['    %s;\n' % struct_or_class(namespace, x) for x in types]
+    result += ['    class %s;\n' % x for x in types]
     result.append('}\n')
     return ''.join(result)
 
diff -Naurp WebKit-r68833/WebKit2/Scripts/webkit2/messages_unittest.py wxwebkit/WebKit2/Scripts/webkit2/messages_unittest.py
--- WebKit-r68833/WebKit2/Scripts/webkit2/messages_unittest.py	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKit2/Scripts/webkit2/messages_unittest.py	2010-10-23 03:51:26.692000071 +0400
@@ -57,7 +57,6 @@ messages -> WebPage {
     DidReceivePolicyDecision(uint64_t frameID, uint64_t listenerID, uint32_t policyAction)
     Close()
 
-    PreferencesDidChange(WebKit::WebPreferencesStore store)
     SendDoubleAndFloat(double d, float f)
     SendInts(Vector<uint64_t> ints, Vector<Vector<uint64_t> > intVectors)
 
@@ -82,6 +81,7 @@ _expected_results = {
                 ('WTF::String', 'url'),
             ),
             'condition': None,
+            'base_class': 'CoreIPC::Arguments1<const WTF::String&>',
         },
         {
             'name': 'TouchEvent',
@@ -89,6 +89,7 @@ _expected_results = {
                 ('WebKit::WebTouchEvent', 'event'),
             ),
             'condition': 'ENABLE(TOUCH_EVENTS)',
+            'base_class': 'CoreIPC::Arguments1<const WebKit::WebTouchEvent&>',
         },
         {
             'name': 'DidReceivePolicyDecision',
@@ -98,18 +99,13 @@ _expected_results = {
                 ('uint32_t', 'policyAction'),
             ),
             'condition': None,
+            'base_class': 'CoreIPC::Arguments3<uint64_t, uint64_t, uint32_t>',
         },
         {
             'name': 'Close',
             'parameters': (),
             'condition': None,
-        },
-        {
-            'name': 'PreferencesDidChange',
-            'parameters': (
-                ('WebKit::WebPreferencesStore', 'store'),
-            ),
-            'condition': None,
+            'base_class': 'CoreIPC::Arguments0',
         },
         {
             'name': 'SendDoubleAndFloat',
@@ -118,6 +114,7 @@ _expected_results = {
                 ('float', 'f'),
             ),
             'condition': None,
+            'base_class': 'CoreIPC::Arguments2<double, float>',
         },
         {
             'name': 'SendInts',
@@ -126,6 +123,7 @@ _expected_results = {
                 ('Vector<Vector<uint64_t> >', 'intVectors')
             ),
             'condition': None,
+            'base_class': 'CoreIPC::Arguments1<const Vector<uint64_t>&>',
         },
         {
             'name': 'CreatePlugin',
@@ -137,6 +135,8 @@ _expected_results = {
                 ('bool', 'result'),
             ),
             'condition': None,
+            'base_class': 'CoreIPC::Arguments2<uint64_t, const WebKit::Plugin::Parameters&>',
+            'reply_base_class': 'CoreIPC::Arguments1<bool>',
         },
         {
             'name': 'RunJavaScriptAlert',
@@ -146,6 +146,8 @@ _expected_results = {
             ),
             'reply_parameters': (),
             'condition': None,
+            'base_class': 'CoreIPC::Arguments2<uint64_t, const WTF::String&>',
+            'reply_base_class': 'CoreIPC::Arguments0',
         },
         {
             'name': 'GetPlugins',
@@ -156,6 +158,8 @@ _expected_results = {
                 ('Vector<WebCore::PluginInfo>', 'plugins'),
             ),
             'condition': None,
+            'base_class': 'CoreIPC::Arguments1<bool>',
+            'reply_base_class': 'CoreIPC::Arguments1<Vector<WebCore::PluginInfo>&>',
         },
         {
             'name': 'GetPluginProcessConnection',
@@ -166,6 +170,9 @@ _expected_results = {
                 ('CoreIPC::Connection::Handle', 'connectionHandle'),
             ),
             'condition': None,
+            'base_class': 'CoreIPC::Arguments1<const WTF::String&>',
+            'reply_base_class': 'CoreIPC::Arguments1<CoreIPC::Connection::Handle&>',
+            'delayed_reply_base_class': 'CoreIPC::Arguments1<const CoreIPC::Connection::Handle&>',
         },
         {
             'name': 'DidCreateWebProcessConnection',
@@ -173,6 +180,7 @@ _expected_results = {
                 ('CoreIPC::MachPort', 'connectionIdentifier'),
             ),
             'condition': None,
+            'base_class': 'CoreIPC::Arguments2<double, float>',
         },
     ),
 }
@@ -248,7 +256,6 @@ namespace WTF {
 }
 
 namespace WebKit {
-    struct WebPreferencesStore;
     class WebTouchEvent;
 }
 
@@ -263,7 +270,6 @@ enum Kind {
 #endif
     DidReceivePolicyDecisionID,
     CloseID,
-    PreferencesDidChangeID,
     SendDoubleAndFloatID,
     SendIntsID,
     CreatePluginID,
@@ -303,14 +309,6 @@ struct Close : CoreIPC::Arguments0 {
     static const Kind messageID = CloseID;
 };
 
-struct PreferencesDidChange : CoreIPC::Arguments1<const WebKit::WebPreferencesStore&> {
-    static const Kind messageID = PreferencesDidChangeID;
-    explicit PreferencesDidChange(const WebKit::WebPreferencesStore& store)
-        : CoreIPC::Arguments1<const WebKit::WebPreferencesStore&>(store)
-    {
-    }
-};
-
 struct SendDoubleAndFloat : CoreIPC::Arguments2<double, float> {
     static const Kind messageID = SendDoubleAndFloatID;
     SendDoubleAndFloat(double d, float f)
@@ -423,7 +421,6 @@ _expected_receiver_implementation = """/
 #include "Plugin.h"
 #include "WebEvent.h"
 #include "WebPageMessages.h"
-#include "WebPreferencesStore.h"
 
 namespace WebKit {
 
@@ -444,9 +441,6 @@ void WebPage::didReceiveWebPageMessage(C
     case Messages::WebPage::CloseID:
         CoreIPC::handleMessage<Messages::WebPage::Close>(arguments, this, &WebPage::close);
         return;
-    case Messages::WebPage::PreferencesDidChangeID:
-        CoreIPC::handleMessage<Messages::WebPage::PreferencesDidChange>(arguments, this, &WebPage::preferencesDidChange);
-        return;
     case Messages::WebPage::SendDoubleAndFloatID:
         CoreIPC::handleMessage<Messages::WebPage::SendDoubleAndFloat>(arguments, this, &WebPage::sendDoubleAndFloat);
         return;
diff -Naurp WebKit-r68833/WebKitTools/BuildSlaveSupport/build-launcher-app wxwebkit/WebKitTools/BuildSlaveSupport/build-launcher-app
--- WebKit-r68833/WebKitTools/BuildSlaveSupport/build-launcher-app	2010-07-15 08:45:10.000000000 +0400
+++ wxwebkit/WebKitTools/BuildSlaveSupport/build-launcher-app	2010-10-23 03:51:27.445000071 +0400
@@ -1,6 +1,6 @@
 #!/usr/bin/perl -w
 
-# Copyright (C) 2006, 2007, 2008, 2009 Apple Inc.  All rights reserved.
+# Copyright (C) 2006 Apple Computer, Inc.  All rights reserved.
 # Copyright (C) 2006 Mark Rowe <opendarwin.org@bdash.net.nz>.  All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
@@ -12,7 +12,7 @@
 # 2.  Redistributions in binary form must reproduce the above copyright
 #     notice, this list of conditions and the following disclaimer in the
 #     documentation and/or other materials provided with the distribution. 
-# 3.  Neither the name of Apple Inc. ("Apple") nor the names of
+# 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 #     its contributors may be used to endorse or promote products derived
 #     from this software without specific prior written permission. 
 #
@@ -33,38 +33,11 @@ use strict;
 
 use FindBin;
 use lib "$FindBin::Bin/../Scripts";
-use Cwd 'realpath';
-use Getopt::Long;
 use webkitdirs;
-use VCSUtils;
-
-my $branch;
-my $leopardProductDir;
-my $productDir;
-my $revision;
-my $tigerProductDir;
-my $snowLeopardProductDir;
-
-GetOptions('branch=s' => \$branch,
-           'revision=i' => \$revision,
-           'build-dir=s' => \$productDir,
-           'build-dir-10-4=s' => \$tigerProductDir,
-           'build-dir-10-5=s' => \$leopardProductDir,
-           'build-dir-10-6=s', => \$snowLeopardProductDir);
-
-$branch = currentBranch() unless defined($branch);
-$revision = currentSVNRevision() unless defined($revision);
-
-setBaseProductDir($productDir);
 
 my @xcodeBuildArguments = XcodeOptions();
-unshift @xcodeBuildArguments, "SYMROOT=$productDir";
-unshift @xcodeBuildArguments, "OBJROOT=$productDir";
-
 my $nightlyLauncherTemplatePath = "$FindBin::Bin/../WebKitLauncher";
-my $nightlyLauncherStagingPath = $productDir . "/WebKit.app";
-
-my $configuration = $ENV{'RC_JASPER'} eq 'YES' ? '' : configuration();
+my $nightlyLauncherStagingPath = productDir() . "/WebKit.app";
 
 sub buildNightlyLauncher
 {
@@ -74,6 +47,18 @@ sub buildNightlyLauncher
     chdirWebKit();
 }
 
+sub currentRevision
+{
+    my $sourceDir = sourceDir();
+    if (isSVNDirectory($sourceDir)) {
+        return currentSVNRevision();
+    } elsif (isGitDirectory($sourceDir)) {
+        my $gitLog = `cd $sourceDir && LC_ALL=C git log --grep='git-svn-id: ' -n 1 | grep git-svn-id:`;
+        (my $revision) = ($gitLog =~ m/ +git-svn-id: .+@(\d+) /g);
+        return $revision;
+    }
+}
+
 sub currentBranch
 {
     my $sourceDir = sourceDir();
@@ -93,11 +78,13 @@ sub currentBranch
 
 sub copyNightlyLauncher
 {
+    my $revision = currentRevision();
+    my $branch = currentBranch();
+
     my $infoPlist = "$nightlyLauncherStagingPath/Contents/Info.plist";
     my $versionFile = "$nightlyLauncherStagingPath/Contents/Resources/VERSION";
     my $branchFile = "$nightlyLauncherStagingPath/Contents/Resources/BRANCH";
     my $data;
-
     open(IN, $infoPlist) or die "Couldn't open Info.plist in built application for reading";
     {
         undef $/;
@@ -117,40 +104,17 @@ sub copyNightlyLauncher
     print OUT "$branch\n";
     close(OUT);
 
-    my @systemVersions;
-    push @systemVersions, "10.4" if defined $tigerProductDir;
-    push @systemVersions, "10.5" if defined $leopardProductDir;
-    push @systemVersions, "10.6" if defined $snowLeopardProductDir;
-
-    for my $systemVersion (@systemVersions) {
-        my $frameworksPath = "$nightlyLauncherStagingPath/Contents/Frameworks/$systemVersion";
-        mkdir($frameworksPath);
-        symlink("../Sparkle.framework", "$frameworksPath/Sparkle.framework");
-    }
-
     my @frameworks = ("JavaScriptCore", "JavaScriptGlue", "WebCore", "WebKit");
     for my $framework (@frameworks) {
-	for my $systemVersion (@systemVersions) { 
-	    if ($systemVersion eq "10.4") {
-		my $tigerFramework = "$tigerProductDir/$configuration/$framework.framework";
-		system("ditto", $tigerFramework, "$nightlyLauncherStagingPath/Contents/Frameworks/10.4/$framework.framework") == 0 or die "Failed copying $tigerFramework into $nightlyLauncherStagingPath";
-	    } elsif ($systemVersion eq "10.5") {
-		my $leopardFramework = "$leopardProductDir/$configuration/$framework.framework";
-		system("ditto", $leopardFramework, "$nightlyLauncherStagingPath/Contents/Frameworks/10.5/$framework.framework") == 0 or die "Failed copying $leopardFramework into $nightlyLauncherStagingPath";
-	    } elsif ($systemVersion eq "10.6") {
-		my $snowLeopardFramework = "$snowLeopardProductDir/$configuration/$framework.framework";
-		system("ditto", $snowLeopardFramework, "$nightlyLauncherStagingPath/Contents/Frameworks/10.6/$framework.framework") == 0 or die "Failed copying $snowLeopardFramework into $nightlyLauncherStagingPath";
-	    }
-	}
-    }
-
-    for my $systemVersion (@systemVersions) {
-        my $infoPlistWithoutExtension = "$nightlyLauncherStagingPath/Contents/Frameworks/$systemVersion/WebKit.framework/Resources/Info";
-        system("defaults", "write", $infoPlistWithoutExtension, "CFBundleShortVersionString", "r$revision");
-        system("chmod", "go=r", "$infoPlistWithoutExtension.plist");
+        system("ditto", productDir() . "/$framework.framework", "$nightlyLauncherStagingPath/Contents/Resources/$framework.framework") == 0 or die "Failed copying $framework.framework into $nightlyLauncherStagingPath";
     }
 }
 
+my $b = currentBranch();
+my $r = currentRevision();
+print "Branch: ", $b, "\n";
+print "Revision: ", $r, "\n";
+
 chdirWebKit();
 buildNightlyLauncher();
 copyNightlyLauncher();
diff -Naurp WebKit-r68833/WebKitTools/BuildSlaveSupport/build-launcher-dmg wxwebkit/WebKitTools/BuildSlaveSupport/build-launcher-dmg
--- WebKit-r68833/WebKitTools/BuildSlaveSupport/build-launcher-dmg	2010-07-07 05:05:04.000000000 +0400
+++ wxwebkit/WebKitTools/BuildSlaveSupport/build-launcher-dmg	2010-10-23 03:51:27.445000071 +0400
@@ -1,6 +1,6 @@
 #!/usr/bin/perl -w
 
-# Copyright (C) 2006, 2007, 2008, 2009 Apple Inc.  All rights reserved.
+# Copyright (C) 2006 Apple Computer, Inc.  All rights reserved.
 # Copyright (C) 2006 Mark Rowe <opendarwin.org@bdash.net.nz>.  All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
@@ -12,7 +12,7 @@
 # 2.  Redistributions in binary form must reproduce the above copyright
 #     notice, this list of conditions and the following disclaimer in the
 #     documentation and/or other materials provided with the distribution. 
-# 3.  Neither the name of Apple Inc. ("Apple") nor the names of
+# 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 #     its contributors may be used to endorse or promote products derived
 #     from this software without specific prior written permission. 
 #
@@ -31,63 +31,26 @@
 
 use strict;
 
-use Cwd 'realpath';
 use File::Basename;
-use File::Glob ':globally';
-use FindBin;
 use Getopt::Long;
-use URI::Escape;
-
+use FindBin;
 use lib "$FindBin::Bin/../Scripts";
 use webkitdirs;
-use VCSUtils;
 
-my $TMPDIR = `getconf DARWIN_USER_TEMP_DIR`;
-chomp $TMPDIR;
-
-my $branch;
-my $leopardProductDir;
-my $nightlyBuild = 0;
-my $productDir;
-my $revision;
-my $snowLeopardProductDir;
-my $tigerProductDir;
-my $uploadTo;
-GetOptions('upload-to-host=s' => \$uploadTo,
-           'upload-as-nightly!' => \$nightlyBuild,
-           'branch=s' => \$branch,
-           'revision=i' => \$revision,
-           'build-dir=s' => \$productDir,
-           'build-dir-10-4=s' => \$tigerProductDir,
-           'build-dir-10-5=s' => \$leopardProductDir,
-           'build-dir-10-6=s' => \$snowLeopardProductDir);
-
-$branch = currentBranch() unless defined($branch);
-$revision = currentSVNRevision() unless defined($revision);
-
-setBaseProductDir($productDir);
-
-my $configuration = $ENV{'RC_JASPER'} eq 'YES' ? '' : configuration();
-
-my $nightlyLauncherStagingPath = $productDir . "/WebKit.app";
-my $nightlyLauncherDiskImagePath = $productDir . "/WebKit-SVN-r$revision.dmg";
-my $nightlySymbolArchivePath;
-
-my $nightlyRemoteHost = 'rsync://nightly@builds.nightly.webkit.org';
-my $nightlyAdminHost = 'http://admin:admin@nightly.webkit.org';
-
-my @deltaUpdates;
-my $deltaUpdatePath = "$productDir/WebKit-SVN-r$revision";
-
-my @mountedPaths;
-END {
-    foreach my $path (@mountedPaths) {
-        `hdiutil detach $path 2>&1`;
-    }
-}
+my $nightlyLauncherStagingPath = productDir() . "/WebKit.app";
+my $droseraStagingPath = productDir() . "/DroseraLauncher.app";
+my $nightlyLauncherDiskImagePath;
+
+my $nightlyRemoteHost = 'webkit-nightlies@live.nightly.webkit.org';
+my $nightlyRemotePath = "/home/webkit-nightlies";
+my $nightlyRemoteLatestPath = "$nightlyRemotePath/update-latest.sh";
 
 sub buildDiskImage
 {
+    my $revision = currentSVNRevision();
+    my $productDir = productDir();
+    $nightlyLauncherDiskImagePath = productDir() . "/WebKit-SVN-r$revision.dmg";
+    
     print "Removing previous temp source directory (if any)...\n";
     `rm -rf /tmp/WebKitNightly`;
     die "Removing previous temp source directory failed" if $?;
@@ -100,6 +63,10 @@ sub buildDiskImage
     `cp -R \"$nightlyLauncherStagingPath\" /tmp/WebKitNightly/WebKit.app`;
     die "Copying WebKit.app to temp source directory failed" if $?;
 
+    print "Copying Drosera.app to temp source directory...\n";
+    `cp -R \"$droseraStagingPath\" /tmp/WebKitNightly/Drosera.app`;
+    die "Copying Drosera.app to temp source directory failed" if $?;
+
     print "Creating disk image...\n";
     `hdiutil create \"$nightlyLauncherDiskImagePath\" -ov -srcfolder /tmp/WebKitNightly -fs HFS+ -volname \"WebKit\"`;
     die "Creating disk image failed" if $?;
@@ -116,153 +83,13 @@ sub buildDiskImage
     unlink "$nightlyLauncherDiskImagePath.uncompressed.dmg";
 }
 
-sub buildSymbolArchive
-{
-    my $symbolDir = "$productDir/Symbols";
-    my $tigerSymbolDir = "$symbolDir/10.4";
-    my $leopardSymbolDir = "$symbolDir/10.5";
-    my $snowLeopardSymbolDir = "$symbolDir/10.6";
-
-    print "Removing previous symbol directory (if any)...\n";
-    `rm -rf \"$symbolDir\"`;
-    die "Removing previous symbol directory failed" if $?;
-
-    print "Making a new symbol directory...\n";
-    `mkdir -p \"$symbolDir\" \"$tigerSymbolDir\" \"$leopardSymbolDir\" \"$snowLeopardSymbolDir\"`;
-    die "Making a new symbol directory failed" if $?;
-
-    my %allPlatformsInfo = ("tiger" => {"symbols" => $tigerSymbolDir, "products" => $tigerProductDir},
-                            "leopard" => {"symbols" => $leopardSymbolDir, "products" => $leopardProductDir},
-                            "snowleopard" => {"symbols" => $snowLeopardSymbolDir, "products" => $snowLeopardProductDir}
-                            );
-
-    foreach my $platform (qw(tiger leopard snowleopard)) {
-        my $platformInfo = $allPlatformsInfo{$platform};
-        my $platformProductDir = $platformInfo->{"products"};
-        my $platformSymbolDir = $platformInfo->{"symbols"};
-
-        my @dsyms = <$platformProductDir\/$configuration\/*.dSYM>;
-        my @binaries = map { $a = $_; $a =~ s/\.dSYM//g; $a } @dsyms;
-
-        my $platformName = ucfirst($platform);
-        print "Copying $platformName symbols into symbol directory...";
-        foreach my $file (@dsyms, @binaries) {
-            my $name = basename($file);
-            `ditto --nocache $file \"$platformSymbolDir\"/$name`;
-            die "\nCopying $platformName symbols into symbol directory failed" if $?;
-            print ".";
-        }
-        print "\n";
-    }
-
-    $nightlySymbolArchivePath = "$productDir/WebKit-r$revision-symbols.zip";
-    print "Creating symbol archive...\n";
-    `ditto --nocache -c -k $symbolDir $nightlySymbolArchivePath`;
-    die "Creating symbol archive failed" if $?;
-}
-
-sub buildDeltas
-{
-    my $branch = shift(@_);
-
-    print "Building deltas...\n";
-    open BUILDS, "curl --silent 'http://nightly.webkit.org/builds/trunk/mac/all' |";
-
-    my $mountPoint = "${TMPDIR}WebKit-SVN-r$revision";
-    `hdiutil attach -mountpoint '$mountPoint' -noautoopen -noverify '$nightlyLauncherDiskImagePath'`;
-    push @mountedPaths, $mountPoint;
-
-    my @olderBuilds;
-    while (<BUILDS>) {
-        chomp;
-        my ($buildRevision, $buildTimestamp, $buildURL) = split(/,/);
-        if ($buildRevision < $revision) {
-            push @olderBuilds, +{ "revision" => $buildRevision, "url" => $buildURL };
-        }
-    }
-    close BUILDS;
-
-    mkdir $deltaUpdatePath;
-    for (my $i = 0; $i < 5; $i++) {
-        my $build = $olderBuilds[$i];
-        my $buildRevision = $build->{"revision"};
-        my $buildURL = $build->{"url"};
-        my $buildMountPoint = "${TMPDIR}WebKit-SVN-r$buildRevision";
-        my $buildPath = "$buildMountPoint.dmg";
-
-        my $patchPath = $deltaUpdatePath . "/WebKit-r$buildRevision-to-r$revision.delta";
-
-        print "Generating delta from r$buildRevision to r$revision...\n";
-
-        unlink $buildPath;
-        system "curl --silent -L -o '$buildPath' '$buildURL'";
-        die "Failed to download build." if $?;
-        `hdiutil attach -mountpoint '$buildMountPoint' -noautoopen -noverify -nobrowse '$buildPath'`;
-        die "Failed to mount build." if $?;
-        push @mountedPaths, $buildMountPoint;
-
-        system "$productDir/BinaryDelta", "create", "$buildMountPoint/WebKit.app", "$mountPoint/WebKit.app", $patchPath;
-        die "Failed to create delta" if $?;
-
-        push @deltaUpdates, +{ "revision" => $buildRevision, "file" => $patchPath };
-
-        `hdiutil detach '$buildMountPoint'`;
-        die "Failed to unmount build." if $?;
-    }
-
-    `hdiutil detach '$mountPoint'`;
-    die "Failed to unmount build." if $?;
-}
-
-sub signFile
+sub uploadNightlyDiskImage
 {
-    my $fileName = shift;
-    my $keyFile = "$ENV{HOME}/.nightly.webkit.org/nightly.webkit.org.private.pem";
-    my $signature = `openssl dgst -sha1 -binary < "$fileName" | openssl dgst -dss1 -sign "$keyFile" | openssl enc -base64`;
-    chomp($signature);
-    return $signature;
-}
-
-sub escapeSignatureForURL
-{
-    my $signature = shift;
-    $signature =~ s/(.)/sprintf("%X",ord($1))/eg;
-    return $signature;
-}
-
-sub uploadNightlyBuild
-{
-    my $branch = shift(@_);
-    my $fileName = basename($nightlyLauncherDiskImagePath);
-    my $nightlyRemoteDiskImagePath = "webkit-builds/files/$branch/mac/" . $fileName;
-
-    my $signature = escapeSignatureForURL(signFile($nightlyLauncherDiskImagePath));
-    system("rsync", "--password-file=$ENV{HOME}/.nightly.webkit.org/rsync-password", "-vP", $nightlyLauncherDiskImagePath, "$nightlyRemoteHost/$nightlyRemoteDiskImagePath") == 0 or die "Failed uploading disk image";
-    system("curl", "-H", "Accept: text/plain", "$nightlyAdminHost/admin/register-build/$branch/mac/$revision/$fileName?signature=$signature") == 0 or die "Failed to register build";
-
-    my $nightlyRemoteDeltaPath = "webkit-builds/files/$branch/mac/";
-    system("rsync", "--password-file=$ENV{HOME}/.nightly.webkit.org/rsync-password", "-rvP", $deltaUpdatePath, "$nightlyRemoteHost/$nightlyRemoteDeltaPath") == 0 or die "Failed uploading deltas";
-    foreach my $delta (@deltaUpdates) {
-        my $deltaFrom = $delta->{"revision"};
-        $fileName = basename($deltaUpdatePath) . "/" . basename($delta->{"file"});
-        $signature = escapeSignatureForURL(signFile($delta->{"file"}));
-        system("curl", "-H", "Accept: text/plain", "$nightlyAdminHost/admin/register-delta-update/$branch/mac/$deltaFrom/$revision/$fileName?signature=$signature") == 0 or die "Failed to register delta update";
-    }
-}
-
-sub uploadNightlySymbolArchive
-{
-    my $branch = shift(@_);
-    my $fileName = basename($nightlySymbolArchivePath);
-    my $nightlyRemoteSymbolArchivePath = "webkit-builds/symbols/$branch/mac/" . $fileName;
-
-    system("rsync", "--password-file=$ENV{HOME}/.nightly.webkit.org/rsync-password", "-vP", $nightlySymbolArchivePath, "$nightlyRemoteHost/$nightlyRemoteSymbolArchivePath") == 0 or die "Failed uploading symbol archive";
-#    system("curl", "-H", "Host: nightly.webkit.org", "-H", "Accept: text/plain", "$nightlyAdminHost/admin/register-symbols/$branch/mac/$revision/$fileName") == 0 or die "Failed to register symbols";
-}
-
-sub purgeNightlyCache
-{
-    system("curl", "-H", "Host: nightly.webkit.org", "-H", "Accept: text/plain", "$nightlyAdminHost/admin/purge-cache") == 0 or die "Failed to purge cache";
+    my $buildTag = shift(@_);
+    my $nightlyRemoteDiskImagePath = "$nightlyRemotePath/builds/$buildTag/mac/" . basename($nightlyLauncherDiskImagePath);
+    my $revision = currentSVNRevision();
+    system("rsync", "-vP", $nightlyLauncherDiskImagePath, "$nightlyRemoteHost:$nightlyRemoteDiskImagePath") == 0 or die "Failed uploading disk image";
+    system("ssh", $nightlyRemoteHost, $nightlyRemoteLatestPath, $buildTag, "mac", $nightlyRemoteDiskImagePath, $revision) == 0 or die "Failed linking disk image to latest";
 }
 
 sub uploadBuildSlaveDiskImage
@@ -271,15 +98,19 @@ sub uploadBuildSlaveDiskImage
     system("rsync", "-vP", $nightlyLauncherDiskImagePath, $remoteDiskImagePath) == 0 or die "Failed uploading disk image";
 }
 
+
+my $uploadTo;
+my $nightlyBuild = 0;
+my $buildTag = 'trunk';
+GetOptions('upload-to-host=s' => \$uploadTo,
+           'upload-as-nightly!' => \$nightlyBuild,
+           'tag=s' => \$buildTag);
+
 chdirWebKit();
-buildDiskImage($branch);
-# buildSymbolArchive($branch);
+buildDiskImage($buildTag);
 
 if ($nightlyBuild) {
-    buildDeltas($branch);
-    uploadNightlyBuild($branch);
-    # uploadNightlySymbolArchive($branch);
-    purgeNightlyCache();
+    uploadNightlyDiskImage($buildTag);
 } elsif ($uploadTo) {
     uploadBuildSlaveDiskImage($uploadTo);
 } else {
diff -Naurp WebKit-r68833/WebKitTools/BuildSlaveSupport/build.webkit.org-config/config.json wxwebkit/WebKitTools/BuildSlaveSupport/build.webkit.org-config/config.json
--- WebKit-r68833/WebKitTools/BuildSlaveSupport/build.webkit.org-config/config.json	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKitTools/BuildSlaveSupport/build.webkit.org-config/config.json	2010-10-23 03:51:27.446000071 +0400
@@ -95,7 +95,7 @@
                     {
                       "name": "Windows Release (Tests)", "type": "Test", "builddir": "win-release-tests",
                       "platform": "win", "configuration": "release", "architectures": ["i386"],
-                      "slavenames": ["apple-windows-3", "apple-windows-5", "test-slave"]
+                      "slavenames": ["apple-windows-4", "apple-windows-3", "apple-windows-5", "apple-windows-6", "test-slave"]
                     },
                     {
                       "name": "Windows Debug (Build)", "type": "Build", "builddir": "win-debug",
@@ -106,7 +106,7 @@
                     {
                       "name": "Windows Debug (Tests)", "type": "Test", "builddir": "win-debug-tests",
                       "platform": "win", "configuration": "debug", "architectures": ["i386"],
-                      "slavenames": ["apple-windows-4", "apple-windows-6", "test-slave"]
+                      "slavenames": ["apple-windows-4", "apple-windows-3", "apple-windows-5", "apple-windows-6", "test-slave"]
                     },
                     { "name": "Windows Debug (WebKit2 Tests)", "type": "TestWebKit2", "builddir": "win-debug-tests-wk2",
                       "platform": "win", "configuration": "debug", "architectures": ["i386"],
diff -Naurp WebKit-r68833/WebKitTools/DumpRenderTree/qt/DumpRenderTree.pro wxwebkit/WebKitTools/DumpRenderTree/qt/DumpRenderTree.pro
--- WebKit-r68833/WebKitTools/DumpRenderTree/qt/DumpRenderTree.pro	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKitTools/DumpRenderTree/qt/DumpRenderTree.pro	2010-10-23 03:51:27.516000071 +0400
@@ -27,14 +27,12 @@ HEADERS = $$BASEDIR/WorkQueue.h \
     WorkQueueItemQt.h \
     LayoutTestControllerQt.h \
     GCControllerQt.h \
-    PlainTextControllerQt.h \
     testplugin.h
 SOURCES = ../../../JavaScriptCore/wtf/Assertions.cpp \
     $$BASEDIR/WorkQueue.cpp \
     DumpRenderTreeQt.cpp \
     EventSenderQt.cpp \
     TextInputControllerQt.cpp \
-    PlainTextControllerQt.cpp \
     WorkQueueItemQt.cpp \
     LayoutTestControllerQt.cpp \
     GCControllerQt.cpp \
diff -Naurp WebKit-r68833/WebKitTools/DumpRenderTree/qt/DumpRenderTreeQt.cpp wxwebkit/WebKitTools/DumpRenderTree/qt/DumpRenderTreeQt.cpp
--- WebKit-r68833/WebKitTools/DumpRenderTree/qt/DumpRenderTreeQt.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKitTools/DumpRenderTree/qt/DumpRenderTreeQt.cpp	2010-10-23 03:51:27.516000071 +0400
@@ -37,7 +37,6 @@
 #include "GCControllerQt.h"
 #include "LayoutTestControllerQt.h"
 #include "TextInputControllerQt.h"
-#include "PlainTextControllerQt.h"
 #include "testplugin.h"
 #include "WorkQueue.h"
 
@@ -471,7 +470,6 @@ DumpRenderTree::DumpRenderTree()
     connect(m_controller, SIGNAL(done()), this, SLOT(dump()));
     m_eventSender = new EventSender(m_page);
     m_textInputController = new TextInputController(m_page);
-    m_plainTextController = new PlainTextController(m_page);
     m_gcController = new GCController(m_page);
 
     // now connect our different signals
@@ -754,7 +752,6 @@ void DumpRenderTree::initJSObjects()
     frame->addToJavaScriptWindowObject(QLatin1String("eventSender"), m_eventSender);
     frame->addToJavaScriptWindowObject(QLatin1String("textInputController"), m_textInputController);
     frame->addToJavaScriptWindowObject(QLatin1String("GCController"), m_gcController);
-    frame->addToJavaScriptWindowObject(QLatin1String("plainText"), m_plainTextController);
 }
 
 void DumpRenderTree::showPage()
diff -Naurp WebKit-r68833/WebKitTools/DumpRenderTree/qt/DumpRenderTreeQt.h wxwebkit/WebKitTools/DumpRenderTree/qt/DumpRenderTreeQt.h
--- WebKit-r68833/WebKitTools/DumpRenderTree/qt/DumpRenderTreeQt.h	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKitTools/DumpRenderTree/qt/DumpRenderTreeQt.h	2010-10-23 03:51:27.516000071 +0400
@@ -60,7 +60,6 @@ class DumpRenderTreeSupportQt;
 class EventSender;
 class TextInputController;
 class GCController;
-class PlainTextController;
 
 namespace WebCore {
 
@@ -149,7 +148,6 @@ private:
     EventSender *m_eventSender;
     TextInputController *m_textInputController;
     GCController* m_gcController;
-    PlainTextController* m_plainTextController;
     NetworkAccessManager* m_networkAccessManager;
 
     QFile *m_stdin;
diff -Naurp WebKit-r68833/WebKitTools/DumpRenderTree/qt/PlainTextControllerQt.cpp wxwebkit/WebKitTools/DumpRenderTree/qt/PlainTextControllerQt.cpp
--- WebKit-r68833/WebKitTools/DumpRenderTree/qt/PlainTextControllerQt.cpp	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKitTools/DumpRenderTree/qt/PlainTextControllerQt.cpp	1970-01-01 03:00:00.000000000 +0300
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2010 Robert Hogan <robert@roberthogan.net>
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1.  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- * 2.  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
- *     its contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#include "config.h"
-#include "PlainTextControllerQt.h"
-
-#include "../../../WebKit/qt/WebCoreSupport/DumpRenderTreeSupportQt.h"
-#include <QApplication>
-#include <QInputMethodEvent>
-#include <QKeyEvent>
-
-PlainTextController::PlainTextController(QWebPage* parent)
-    : QObject(parent)
-{
-}
-
-QString PlainTextController::plainText(const QVariant& range)
-{
-    return DumpRenderTreeSupportQt::plainText(range);
-}
diff -Naurp WebKit-r68833/WebKitTools/DumpRenderTree/qt/PlainTextControllerQt.h wxwebkit/WebKitTools/DumpRenderTree/qt/PlainTextControllerQt.h
--- WebKit-r68833/WebKitTools/DumpRenderTree/qt/PlainTextControllerQt.h	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKitTools/DumpRenderTree/qt/PlainTextControllerQt.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2010 Robert Hogan <robert@roberthogan.net>
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1.  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- * 2.  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
- *     its contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef PlainTextControllerQt_h
-#define PlainTextControllerQt_h
-
-#include <QList>
-#include <QObject>
-#include <QString>
-#include <QVariant>
-
-#include "qwebpage.h"
-
-class PlainTextController : public QObject {
-    Q_OBJECT
-public:
-    PlainTextController(QWebPage* parent);
-
-public slots:
-    QString plainText(const QVariant& range);
-};
-
-#endif // PlainTextControllerQt_h
diff -Naurp WebKit-r68833/WebKitTools/Scripts/webkitpy/common/net/buildbot.py wxwebkit/WebKitTools/Scripts/webkitpy/common/net/buildbot.py
--- WebKit-r68833/WebKitTools/Scripts/webkitpy/common/net/buildbot.py	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKitTools/Scripts/webkitpy/common/net/buildbot.py	2010-10-23 03:51:27.564000071 +0400
@@ -166,13 +166,12 @@ class Builder(object):
                 failures = set(results.failing_tests())
                 if common_failures == None:
                     common_failures = failures
-                else:
-                    common_failures = common_failures.intersection(failures)
-                    if not common_failures:
-                        # current_build doesn't have any failures in common with
-                        # the red build we're worried about.  We assume that any
-                        # failures in current_build were due to flakiness.
-                        break
+                common_failures = common_failures.intersection(failures)
+                if not common_failures:
+                    # current_build doesn't have any failures in common with
+                    # the red build we're worried about.  We assume that any
+                    # failures in current_build were due to flakiness.
+                    break
             look_back_count += 1
             if look_back_count > look_back_limit:
                 return RegressionWindow(None, current_build, failing_tests=common_failures)
@@ -462,8 +461,7 @@ class BuildBot(object):
                 continue
             builder = self.builder_with_name(builder_status["name"])
             regression_window = builder.find_blameworthy_regression_window(builder_status["build_number"])
-            if regression_window:
-                failure_map.add_regression_window(builder, regression_window)
+            failure_map.add_regression_window(builder, regression_window)
         return failure_map
 
     # This makes fewer requests than calling Builder.latest_build would.  It grabs all builder
diff -Naurp WebKit-r68833/WebKitTools/Scripts/webkitpy/common/net/failuremap.py wxwebkit/WebKitTools/Scripts/webkitpy/common/net/failuremap.py
--- WebKit-r68833/WebKitTools/Scripts/webkitpy/common/net/failuremap.py	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKitTools/Scripts/webkitpy/common/net/failuremap.py	2010-10-23 03:51:27.564000071 +0400
@@ -51,9 +51,8 @@ class FailureMap(object):
     def tests_failing_for(self, revision):
         tests = [failure_info['regression_window'].failing_tests()
                  for failure_info in self._failures
-                 if revision in failure_info['regression_window'].revisions()
-                    and failure_info['regression_window'].failing_tests()]
-        return sorted(set(sum(tests, [])))
+                 if revision in failure_info['regression_window'].revisions()]
+        return sorted(set(sum(failing_tests, [])))
 
     def _old_failures(self, is_old_failure):
         return filter(lambda revision: is_old_failure(revision),
diff -Naurp WebKit-r68833/WebKitTools/Scripts/webkitpy/common/net/failuremap_unittest.py wxwebkit/WebKitTools/Scripts/webkitpy/common/net/failuremap_unittest.py
--- WebKit-r68833/WebKitTools/Scripts/webkitpy/common/net/failuremap_unittest.py	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKitTools/Scripts/webkitpy/common/net/failuremap_unittest.py	2010-10-23 03:51:27.564000071 +0400
@@ -70,7 +70,3 @@ class FailureMapTest(unittest.TestCase):
         failure_map = self._make_failure_map()
         failure_map.filter_out_old_failures(lambda revision: revision == 1235)
         self.assertEquals(failure_map.failing_revisions(), [1234])
-
-    def test_tests_failing_for(self):
-        failure_map = self._make_failure_map()
-        self.assertEquals(failure_map.tests_failing_for(1234), [])
diff -Naurp WebKit-r68833/WebKitTools/Scripts/webkitpy/tool/commands/queries.py wxwebkit/WebKitTools/Scripts/webkitpy/tool/commands/queries.py
--- WebKit-r68833/WebKitTools/Scripts/webkitpy/tool/commands/queries.py	2010-10-01 01:57:42.000000000 +0400
+++ wxwebkit/WebKitTools/Scripts/webkitpy/tool/commands/queries.py	2010-10-23 03:51:27.624000069 +0400
@@ -278,18 +278,18 @@ class FindFlakyTests(AbstractDeclarative
         build = builder.build_for_revision(revision, allow_failed_lookups=True)
         if not build:
             print "No build for %s" % revision
-            return (None, None)
+            return None
         results = build.layout_test_results()
         if not results:
             print "No results build %s (r%s)" % (build._number, build.revision())
-            return (None, None)
+            return None
         failures = set(results.failing_tests())
         if len(failures) >= 20:
             # FIXME: We may need to move this logic into the LayoutTestResults class.
             # The buildbot stops runs after 20 failures so we don't have full results to work with here.
             print "Too many failures in build %s (r%s), ignoring." % (build._number, build.revision())
-            return (None, None)
-        return (build, failures)
+            return None
+        return failures
 
     def _increment_statistics(self, flaky_tests, flaky_test_statistics):
         for test in flaky_tests:
@@ -306,23 +306,20 @@ class FindFlakyTests(AbstractDeclarative
         flaky_test_statistics = {}
         all_previous_failures = set([])
         one_time_previous_failures = set([])
-        previous_build = None
         for i in range(limit):
             revision = start_revision - i
             print "Analyzing %s ... " % revision,
-            (build, failures) = self._find_failures(builder, revision)
+            failures = self._find_failures(builder, revision)
             if failures == None:
                 # Notice that we don't loop on the empty set!
                 continue
             print "has %s failures" % len(failures)
             flaky_tests = one_time_previous_failures - failures
             if flaky_tests:
-                print "Flaky tests: %s %s" % (sorted(flaky_tests),
-                                              previous_build.results_url())
+                print "Flaky tests: %s" % sorted(flaky_tests)
             self._increment_statistics(flaky_tests, flaky_test_statistics)
             one_time_previous_failures = failures - all_previous_failures
             all_previous_failures = failures
-            previous_build = build
         self._print_statistics(flaky_test_statistics)
 
     def _builder_to_analyze(self):
diff -Naurp WebKit-r68833/WebKitTools/wx/build/build_utils.py wxwebkit/WebKitTools/wx/build/build_utils.py
--- WebKit-r68833/WebKitTools/wx/build/build_utils.py	1970-01-01 03:00:00.000000000 +0300
+++ wxwebkit/WebKitTools/wx/build/build_utils.py	2010-10-23 03:51:27.657000069 +0400
@@ -0,0 +1,188 @@
+# Copyright (C) 2009 Kevin Ollivier  All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
+# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+#
+# Helper functions for the WebKit build.
+
+import commands
+import glob
+import os
+import platform
+import re
+import shutil
+import sys
+import urllib
+import urlparse
+
+def get_output(command):
+    """
+    Windows-compatible function for getting output from a command.
+    """
+    if sys.platform.startswith('win'):
+        f = os.popen(command)
+        return f.read().strip()
+    else:
+        return commands.getoutput(command)
+    
+def get_excludes(root, patterns):
+    """
+    Get a list of exclude patterns going down several dirs. 
+    TODO: Make this fully recursive.
+    """
+    excludes = []
+    
+    for pattern in patterns:
+        subdir_pattern = os.sep + '*'
+        for subdir in [subdir_pattern, subdir_pattern*2, subdir_pattern*3]:
+            adir = root + subdir + os.sep + pattern
+            files = glob.glob(adir)
+            for afile in files:
+                excludes.append(os.path.basename(afile))
+
+    return excludes
+    
+def get_dirs_for_features(root, features, dirs):
+    """
+    Find which directories to include in the list of build dirs based upon the 
+    enabled port(s) and features.
+    """
+    outdirs = dirs
+    for adir in dirs:
+        for feature in features:
+            relpath = os.path.join(adir, feature)
+            featuredir = os.path.join(root, relpath)
+            if os.path.exists(featuredir) and not relpath in outdirs:
+                outdirs.append(relpath)
+            
+    return outdirs
+
+def download_if_newer(url, destdir):
+    """
+    Checks if the file on the server is newer than the one in the user's tree,
+    and if so, downloads it. 
+    
+    Returns the filename of the downloaded file if downloaded, or None if 
+    the existing file matches the one on the server.
+    """
+    obj = urlparse.urlparse(url)
+    filename = os.path.basename(obj.path)
+    destfile = os.path.join(destdir, filename)
+    
+    urlobj = urllib.urlopen(url)
+    size = long(urlobj.info().getheader('Content-Length'))
+
+    def download_callback(downloaded, block_size, total_size): 
+        downloaded = block_size * downloaded
+        if downloaded > total_size:
+            downloaded = total_size
+        sys.stdout.write('%s %d of %d bytes downloaded\r' % (filename, downloaded, total_size))
+    
+    # NB: We don't check modified time as Python doesn't yet handle timezone conversion
+    # properly when converting strings to time objects.
+    if not os.path.exists(destfile) or os.path.getsize(destfile) != size:
+        urllib.urlretrieve(url, destfile, download_callback)
+        print ''
+        return destfile
+    
+    return None
+    
+def update_wx_deps(conf, wk_root, msvc_version='msvc2008'):
+    """
+    Download and update tools needed to build the wx port.
+    """
+    import Logs
+    Logs.info('Ensuring wxWebKit dependencies are up-to-date.')
+    
+    wklibs_dir = os.path.join(wk_root, 'WebKitLibraries')
+    waf = download_if_newer('http://wxwebkit.wxcommunity.com/downloads/deps/waf', os.path.join(wk_root, 'WebKitTools', 'wx'))
+    if waf:
+        # TODO: Make the build restart itself after an update.
+        Logs.warn('Build system updated, please restart build.')
+        sys.exit(1)
+
+    # since this module is still experimental
+    wxpy_dir = os.path.join(wk_root, 'WebKit', 'wx', 'bindings', 'python')
+    swig_module = download_if_newer('http://wxwebkit.wxcommunity.com/downloads/deps/swig.py.txt', wxpy_dir)
+    if swig_module:
+        shutil.copy(os.path.join(wxpy_dir, 'swig.py.txt'), os.path.join(wxpy_dir, 'swig.py'))
+
+    if sys.platform.startswith('win'):
+        Logs.info('downloading deps package')
+        archive = download_if_newer('http://wxwebkit.wxcommunity.com/downloads/deps/wxWebKitDeps-%s.zip' % msvc_version, wklibs_dir)
+        if archive and os.path.exists(archive):
+            os.system('unzip -o %s -d %s' % (archive, os.path.join(wklibs_dir, msvc_version)))
+    
+    elif sys.platform.startswith('darwin'):
+        # export the right compiler for building the dependencies
+        if platform.release().startswith('10'): # Snow Leopard
+            os.environ['CC'] = conf.env['CC'][0]
+            os.environ['CXX'] = conf.env['CXX'][0]
+        os.system('%s/WebKitTools/wx/install-unix-extras' % wk_root)
+        
+def includeDirsForSources(sources):
+    include_dirs = []
+    for group in sources:
+        for source in group:
+            dirname = os.path.dirname(source)
+            if not dirname in include_dirs:
+                include_dirs.append(dirname)
+            
+    return include_dirs
+
+def flattenSources(sources):
+    flat_sources = []
+    for group in sources:
+        flat_sources.extend(group)
+        
+    return flat_sources
+
+def git_branch_name():
+    try:
+        branches = commands.getoutput("git branch --no-color")
+        match = re.search('^\* (.*)', branches, re.MULTILINE)
+        if match:
+            return ".%s" % match.group(1)
+    except:
+        pass
+
+    return ""
+
+def get_config(wk_root):
+    config_file = os.path.join(wk_root, 'WebKitBuild', 'Configuration')
+    config = 'Debug'
+
+    if os.path.exists(config_file):
+        config = open(config_file).read()
+
+    return config
+
+def svn_revision():
+    if os.system("git-svn info") == 0:
+        info = commands.getoutput("git-svn info ../..")
+    else:
+        info = commands.getoutput("svn info")
+    
+    for line in info.split("\n"):
+        if line.startswith("Revision: "):
+            return line.replace("Revision: ", "").strip()
+    
+    return ""
diff -Naurp WebKit-r68833/WebKitTools/wx/build/settings.py wxwebkit/WebKitTools/wx/build/settings.py
--- WebKit-r68833/WebKitTools/wx/build/settings.py	1970-01-01 03:00:00.000000000 +0300
+++ wxwebkit/WebKitTools/wx/build/settings.py	2010-10-23 03:51:27.657000069 +0400
@@ -0,0 +1,405 @@
+# Copyright (C) 2009 Kevin Ollivier  All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
+# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+#
+# Common elements of the waf build system shared by all projects.
+
+import commands
+import os
+import platform
+import re
+import sys
+
+import Options
+
+from build_utils import *
+from waf_extensions import *
+
+# to be moved to wx when it supports more configs
+from wxpresets import *
+
+wk_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../..'))
+
+if sys.platform.startswith('win'):
+    if not 'WXWIN' in os.environ:
+        print "Please set WXWIN to the directory containing wxWidgets."
+        sys.exit(1)
+
+    wx_root = os.environ['WXWIN']
+else:
+    wx_root = commands.getoutput('wx-config --prefix')
+
+jscore_dir = os.path.join(wk_root, 'JavaScriptCore')
+webcore_dir = os.path.join(wk_root, 'WebCore')
+wklibs_dir = os.path.join(wk_root, 'WebKitLibraries')
+
+common_defines = []
+common_cxxflags = []
+common_includes = []
+common_libs = []
+common_libpaths = []
+common_frameworks = []
+
+ports = [
+    'Brew',
+    'Chromium',
+    'Gtk', 
+    'Haiku',
+    'Mac', 
+    'None',
+    'Qt',
+    'Safari',
+    'Win', 
+    'Wince',
+    'wx',
+]
+
+port_uses = {
+    'wx': ['CURL', 'WXGC'],
+}
+
+jscore_dirs = [
+    'API',
+    'bytecode',
+    'bytecompiler',
+    'debugger',
+    'DerivedSources',
+    'interpreter',
+    'jit',
+    'parser',
+    'pcre',
+    'profiler',
+    'runtime',
+    'wtf',
+    'wtf/text',
+    'wtf/unicode',
+    'wtf/unicode/icu',
+    'yarr',
+]
+
+webcore_dirs = [
+    'WebCore/accessibility',
+    'WebCore/bindings',
+    'WebCore/bindings/cpp',
+    'WebCore/bindings/generic',
+    'WebCore/bindings/js',
+    'WebCore/bindings/js/specialization',
+    'WebCore/bridge', 
+    'WebCore/bridge/c',
+    'WebCore/bridge/jsc',
+    'WebCore/css',
+    'WebCore/DerivedSources',
+    'WebCore/dom',
+    'WebCore/dom/default',
+    'WebCore/editing',
+    'WebCore/fileapi',
+    'WebCore/history',
+    'WebCore/html',
+    'WebCore/html/canvas',
+    'WebCore/html/parser',
+    'WebCore/inspector', 
+    'WebCore/loader', 
+    'WebCore/loader/appcache', 
+    'WebCore/loader/archive', 
+    'WebCore/loader/icon',
+    'WebCore/notifications',
+    'WebCore/page',
+    'WebCore/page/animation', 
+    'WebCore/platform', 
+    'WebCore/platform/animation', 
+    'WebCore/platform/graphics',
+    'WebCore/platform/graphics/filters',
+    'WebCore/platform/graphics/transforms',
+    'WebCore/platform/image-decoders',
+    'WebCore/platform/image-decoders/bmp', 
+    'WebCore/platform/image-decoders/gif', 
+    'WebCore/platform/image-decoders/ico', 
+    'WebCore/platform/image-decoders/jpeg', 
+    'WebCore/platform/image-decoders/png',
+    'WebCore/platform/mock',
+    'WebCore/platform/network', 
+    'WebCore/platform/sql', 
+    'WebCore/platform/text',
+    'WebCore/platform/text/transcoder',
+    'WebCore/plugins', 
+    'WebCore/rendering', 
+    'WebCore/rendering/style',
+    'WebCore/rendering/svg',
+    'WebCore/storage',
+    'WebCore/svg',
+    'WebCore/svg/animation',
+    'WebCore/svg/graphics',
+    'WebCore/svg/graphics/filters',
+    
+    'WebCore/websockets', 
+    'WebCore/xml'
+]
+
+config = get_config(wk_root)
+config_dir = config + git_branch_name()
+
+output_dir = os.path.join(wk_root, 'WebKitBuild', config_dir)
+
+build_port = "wx"
+building_on_win32 = sys.platform.startswith('win')
+
+def get_config():
+    waf_configname = config.upper().strip()
+    if building_on_win32:
+        isReleaseCRT = (config == 'Release')
+        if build_port == 'wx':
+            if Options.options.wxpython:
+                isReleaseCRT = True
+        
+        if isReleaseCRT:
+            waf_configname = waf_configname + ' CRT_MULTITHREADED_DLL'
+        else:
+            waf_configname = waf_configname + ' CRT_MULTITHREADED_DLL_DBG'
+
+    return waf_configname
+
+create_hash_table = wk_root + "/JavaScriptCore/create_hash_table"
+if building_on_win32:
+    create_hash_table = get_output('cygpath --unix "%s"' % create_hash_table)
+os.environ['CREATE_HASH_TABLE'] = create_hash_table
+
+feature_defines = ['ENABLE_DATABASE', 'ENABLE_XSLT', 'ENABLE_JAVASCRIPT_DEBUGGER',
+                    'ENABLE_SVG', 'ENABLE_SVG_USE', 'ENABLE_FILTERS', 'ENABLE_SVG_FONTS',
+                    'ENABLE_SVG_ANIMATION', 'ENABLE_SVG_AS_IMAGE', 'ENABLE_SVG_FOREIGN_OBJECT',
+                    'ENABLE_JIT', 'BUILDING_%s' % build_port.upper()]
+
+msvc_version = 'msvc2008'
+
+msvclibs_dir = os.path.join(wklibs_dir, msvc_version, 'win')
+
+def get_path_to_wxconfig():
+    if 'WX_CONFIG' in os.environ:
+        return os.environ['WX_CONFIG']
+    else:
+        return 'wx-config'
+
+def common_set_options(opt):
+    """
+    Initialize common options provided to the user.
+    """
+    opt.tool_options('compiler_cxx')
+    opt.tool_options('compiler_cc')
+    opt.tool_options('python')
+    
+    opt.add_option('--wxpython', action='store_true', default=False, help='Create the wxPython bindings.')
+    opt.add_option('--wx-compiler-prefix', action='store', default='vc',
+                   help='Specify a different compiler prefix (do this if you used COMPILER_PREFIX when building wx itself)')
+    opt.add_option('--macosx-version', action='store', default='', help="Version of OS X to build for.")
+    opt.add_option('--msvc-version', action='store', default='', help="MSVC version to use to build. Use 8 for 2005, 9 for 2008")
+
+def common_configure(conf):
+    """
+    Configuration used by all targets, called from the target's configure() step.
+    """
+    
+    conf.env['MSVC_TARGETS'] = ['x86']
+    
+    if Options.options.msvc_version and Options.options.msvc_version != '':
+        print "msvc version = %s" % Options.options.msvc_version
+        conf.env['MSVC_VERSIONS'] = ['msvc %s.0' % Options.options.msvc_version]
+    else:
+        print "msvc not set!"
+        conf.env['MSVC_VERSIONS'] = ['msvc 9.0', 'msvc 8.0']
+    
+    if sys.platform.startswith('cygwin'):
+        print "ERROR: You must use the Win32 Python from python.org, not Cygwin Python, when building on Windows."
+        sys.exit(1)
+    
+    if sys.platform.startswith('darwin') and build_port == 'wx':
+        import platform
+        if platform.release().startswith('10'): # Snow Leopard
+            # wx currently only supports 32-bit compilation, so we want gcc-4.0 instead of 4.2 on Snow Leopard
+            # unless the user has explicitly set a different compiler.
+            if not "CC" in os.environ:
+                conf.env['CC'] = 'gcc-4.0'
+            if not "CXX" in os.environ:
+                conf.env['CXX'] = 'g++-4.0'
+    conf.check_tool('compiler_cxx')
+    conf.check_tool('compiler_cc')
+    if Options.options.wxpython:
+        conf.check_tool('python')
+        conf.check_python_headers()
+    
+    if sys.platform.startswith('darwin'):
+        conf.check_tool('osx')
+    
+    global msvc_version
+    global msvclibs_dir
+    
+    libprefix = ''
+
+    if building_on_win32:
+        libprefix = 'lib'
+
+        found = conf.get_msvc_versions()
+        found_versions = []
+        for version in found:
+            found_versions.append(version[0])
+            
+        if 'msvc 9.0' in conf.env['MSVC_VERSIONS'] and 'msvc 9.0' in found_versions:
+            msvc_version = 'msvc2008'
+        elif 'msvc 8.0' in conf.env['MSVC_VERSIONS'] and 'msvc 8.0' in found_versions:
+            msvc_version = 'msvc2005'
+        
+        msvclibs_dir = os.path.join(wklibs_dir, msvc_version, 'win')
+
+        # Disable several warnings which occur many times during the build.
+        # Some of them are harmless (4099, 4344, 4396, 4800) and working around
+        # them in WebKit code is probably just not worth it. We can simply do
+        # nothing about the others (4503). A couple are possibly valid but
+        # there are just too many of them in the code so fixing them is
+        # impossible in practice and just results in tons of distracting output
+        # (4244, 4291). Finally 4996 is actively harmful as it is given for
+        # just about any use of standard C/C++ library facilities.
+        conf.env.append_value('CXXFLAGS', [
+            '/wd4099',  # type name first seen using 'struct' now seen using 'class'
+            '/wd4244',  # conversion from 'xxx' to 'yyy', possible loss of data:
+            '/wd4291',  # no matching operator delete found (for placement new)
+            '/wd4344',  # behaviour change in template deduction
+            '/wd4396',  # inline can't be used in friend declaration
+            '/wd4503',  # decorated name length exceeded, name was truncated
+            '/wd4800',  # forcing value to bool 'true' or 'false'
+            '/wd4996',  # deprecated function
+        ])
+
+        # This one also occurs in C code, so disable it there as well.
+        conf.env.append_value('CCFLAGS', ['/wd4996'])
+
+    if build_port == "wx":
+        update_wx_deps(conf, wk_root, msvc_version)
+    
+        conf.env.append_value('CXXDEFINES', ['BUILDING_WX__=1', 'JS_NO_EXPORT'])
+
+        if building_on_win32:
+            conf.env.append_value('LIBPATH', os.path.join(msvclibs_dir, 'lib'))
+            # wx settings
+            global config
+            is_debug = (config == 'Debug')
+            wxdefines, wxincludes, wxlibs, wxlibpaths = get_wxmsw_settings(wx_root, shared=True, unicode=True, debug=is_debug, wxPython=Options.options.wxpython)
+            conf.env['CXXDEFINES_WX'] = wxdefines
+            conf.env['CPPPATH_WX'] = wxincludes
+            conf.env['LIB_WX'] = wxlibs
+            conf.env['LIBPATH_WX'] = wxlibpaths
+
+    if sys.platform.startswith('darwin'):
+        conf.env['LIB_ICU'] = ['icucore']
+    
+        conf.env.append_value('CPPPATH', wklibs_dir)
+        conf.env.append_value('LIBPATH', wklibs_dir)
+        
+        min_version = None
+        
+        mac_target = 'MACOSX_DEPLOYMENT_TARGET'
+        if Options.options.macosx_version != '':
+            min_version = Options.options.macosx_version
+        
+        # WebKit only supports 10.4+, but ppc systems often set this to earlier systems
+        if not min_version:
+            min_version = commands.getoutput('sw_vers -productVersion')[:4]
+            if min_version in ['10.1','10.2','10.3']:
+                min_version = '10.4'
+
+        os.environ[mac_target] = conf.env[mac_target] = min_version        
+
+        sdk_version = min_version
+        if min_version == "10.4":
+            sdk_version += "u"
+            conf.env.append_value('LIB_WKINTERFACE', ['WebKitSystemInterfaceTiger'])
+        else:
+            # NOTE: There is a WebKitSystemInterfaceSnowLeopard, but when we use that
+            # on 10.6, we get a strange missing symbol error, and this library seems to
+            # work fine for wx's purposes.
+            conf.env.append_value('LIB_WKINTERFACE', ['WebKitSystemInterfaceLeopard'])
+        
+        sdkroot = '/Developer/SDKs/MacOSX%s.sdk' % sdk_version
+        sdkflags = ['-arch', 'i386', '-isysroot', sdkroot]
+        
+        conf.env.append_value('CPPFLAGS', sdkflags)
+        conf.env.append_value('LINKFLAGS', sdkflags)
+        
+        conf.env.append_value('CPPPATH_SQLITE3', [os.path.join(wklibs_dir, 'WebCoreSQLite3')])
+        conf.env.append_value('LIB_SQLITE3', ['WebCoreSQLite3'])
+    
+    conf.env.append_value('CXXDEFINES', feature_defines)
+    if config == 'Release':
+        conf.env.append_value('CPPDEFINES', 'NDEBUG')
+        
+    if building_on_win32:
+        conf.env.append_value('CPPPATH', [
+            os.path.join(jscore_dir, 'os-win32'),
+            os.path.join(msvclibs_dir, 'include'),
+            os.path.join(msvclibs_dir, 'include', 'pthreads'),
+            os.path.join(msvclibs_dir, 'lib'),
+            ])
+            
+        conf.env.append_value('LIB', ['libpng', 'libjpeg', 'pthreadVC2'])
+        # common win libs
+        conf.env.append_value('LIB', [
+            'kernel32', 'user32','gdi32','comdlg32','winspool','winmm',
+            'shell32', 'shlwapi', 'comctl32', 'ole32', 'oleaut32', 'uuid', 'advapi32', 
+            'wsock32', 'gdiplus', 'usp10','version'])
+
+        conf.env['LIB_ICU'] = ['icudt', 'icule', 'iculx', 'icuuc', 'icuin', 'icuio', 'icutu']
+        
+        #curl
+        conf.env['LIB_CURL'] = ['libcurl']
+        
+        #sqlite3
+        conf.env['CPPPATH_SQLITE3'] = [os.path.join(msvclibs_dir, 'include', 'SQLite')]
+        conf.env['LIB_SQLITE3'] = ['sqlite3']
+        
+        #libxml2
+        conf.env['LIB_XML'] = ['libxml2']
+        
+        #libxslt
+        conf.env['LIB_XSLT'] = ['libxslt']
+    else:    
+        if build_port == 'wx':
+            port_uses['wx'].append('PTHREADS')
+            conf.env.append_value('LIB', ['jpeg', 'png', 'pthread'])
+            conf.env.append_value('LIBPATH', os.path.join(wklibs_dir, 'unix', 'lib'))
+            conf.env.append_value('CPPPATH', os.path.join(wklibs_dir, 'unix', 'include'))
+            conf.env.append_value('CXXFLAGS', ['-fPIC', '-DPIC'])
+            
+            conf.check_cfg(path=get_path_to_wxconfig(), args='--cxxflags --libs', package='', uselib_store='WX', mandatory=True)
+            
+        conf.check_cfg(msg='Checking for libxslt', path='xslt-config', args='--cflags --libs', package='', uselib_store='XSLT', mandatory=True)
+        conf.check_cfg(path='xml2-config', args='--cflags --libs', package='', uselib_store='XML', mandatory=True)
+        if sys.platform.startswith('darwin') and min_version and min_version == '10.4':
+            conf.check_cfg(path=os.path.join(wklibs_dir, 'unix', 'bin', 'curl-config'), args='--cflags --libs', package='', uselib_store='CURL', mandatory=True)
+        else:
+            conf.check_cfg(path='curl-config', args='--cflags --libs', package='', uselib_store='CURL', mandatory=True)
+        
+        if not sys.platform.startswith('darwin'):
+            conf.check_cfg(package='cairo', args='--cflags --libs', uselib_store='WX', mandatory=True)
+            conf.check_cfg(package='pango', args='--cflags --libs', uselib_store='WX', mandatory=True)
+            conf.check_cfg(package='gtk+-2.0', args='--cflags --libs', uselib_store='WX', mandatory=True)
+            conf.check_cfg(package='sqlite3', args='--cflags --libs', uselib_store='SQLITE3', mandatory=True)
+            conf.check_cfg(path='icu-config', args='--cflags --ldflags', package='', uselib_store='ICU', mandatory=True)
+
+    for use in port_uses[build_port]:
+       conf.env.append_value('CXXDEFINES', ['WTF_USE_%s' % use])
diff -Naurp WebKit-r68833/WebKitTools/wx/build/waf_extensions.py wxwebkit/WebKitTools/wx/build/waf_extensions.py
--- WebKit-r68833/WebKitTools/wx/build/waf_extensions.py	1970-01-01 03:00:00.000000000 +0300
+++ wxwebkit/WebKitTools/wx/build/waf_extensions.py	2010-10-23 03:51:27.657000069 +0400
@@ -0,0 +1,83 @@
+# Copyright (C) 2009 Kevin Ollivier  All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
+# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+#
+# This module is for code where we override waf's default behavior or extend waf
+
+import os
+import subprocess
+import sys
+
+import Utils
+
+# version of exec_command that handles Windows command lines longer than 32000 chars
+def exec_command(s, **kw):
+    filename = ''
+    if sys.platform.startswith('win') and len(' '.join(s)) > 32000:
+        import tempfile
+        (fd, filename) = tempfile.mkstemp()
+        t = []
+        for i in s:
+            if i.find(" ") != -1:
+                i = '"%s"' % i
+            t.append(i)
+        os.write(fd, ' '.join(t[1:]))
+        os.close(fd)
+        
+        s = [s[0], '@' + filename]
+        
+    if 'log' in kw:
+        kw['stdout'] = kw['stderr'] = kw['log']
+        del(kw['log'])
+    kw['shell'] = isinstance(s, str)
+
+    def cleanup():
+        try:
+            if os.path.exists(filename):
+                os.remove(filename)
+        except:
+            pass
+
+    try:
+        proc = subprocess.Popen(s, **kw)
+        result = proc.wait()
+        cleanup()
+        return result
+        
+    except OSError:
+        cleanup()
+        raise
+        
+Utils.exec_command = exec_command
+
+# Better performing h_file to keep hashing from consuming lots of time
+import stat
+def h_file(filename):
+    st = os.stat(filename)
+    if stat.S_ISDIR(st[stat.ST_MODE]): raise IOError('not a file')
+    m = Utils.md5()
+    m.update(str(st.st_mtime))
+    m.update(str(st.st_size))
+    m.update(filename)
+    return m.digest()
+
+Utils.h_file = h_file
diff -Naurp WebKit-r68833/WebKitTools/wx/build/wxpresets.py wxwebkit/WebKitTools/wx/build/wxpresets.py
--- WebKit-r68833/WebKitTools/wx/build/wxpresets.py	1970-01-01 03:00:00.000000000 +0300
+++ wxwebkit/WebKitTools/wx/build/wxpresets.py	2010-10-23 03:51:27.657000069 +0400
@@ -0,0 +1,120 @@
+# Copyright (C) 2009 Kevin Ollivier  All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
+# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+#
+# Library for functions to determine wx settings based on configuration
+
+import os
+import re
+
+import Options
+
+def parse_build_cfg(filename):
+    cfg_file = open(filename, 'r')
+    cfg = {}
+    for cfg_line in cfg_file.readlines():
+        key = None
+        value = None
+        parts = cfg_line.split('=')
+        if len(parts) >= 1:
+            key = parts[0].strip()
+        
+        if len(parts) >= 2:
+            value = parts[1].strip()
+            if value.isdigit():
+                value = int(value)
+        
+        if key:
+            cfg[key] = value
+
+    return cfg
+
+def get_wx_version(wx_root):
+    versionText = open(os.path.join(wx_root, "include", "wx", "version.h"), "r").read()
+    
+    majorVersion = re.search("#define\swxMAJOR_VERSION\s+(\d+)", versionText).group(1)
+    minorVersion = re.search("#define\swxMINOR_VERSION\s+(\d+)", versionText).group(1)
+    
+    return (majorVersion, minorVersion)
+
+def get_wxmsw_settings(wx_root, shared = False, unicode = False, debug = False, wxPython=False):
+    if not os.path.exists(wx_root):
+        print "Directory %s does not exist." % wx_root
+        sys.exit(1)
+
+    defines = ['__WXMSW__']
+    includes = [os.path.join(wx_root, 'include')]
+    cxxflags = []
+    libs = []
+    libpaths = []
+    
+    libdir = os.path.join(wx_root, 'lib')
+    ext = ''
+    postfix = 'vc'
+    
+    version_str_nodot = ''.join(get_wx_version(wx_root))
+    
+    if shared:
+        defines.append('WXUSINGDLL')
+        libdir = os.path.join(libdir, Options.options.wx_compiler_prefix + '_dll')
+    else:
+        libdir = os.path.join(libdir, Options.options.wx_compiler_prefix + '_lib')
+        
+    if unicode:
+        defines.append('_UNICODE')
+        ext += 'u'
+    
+    depext = ''
+    if wxPython:
+        ext += 'h'
+        depext += 'h'
+    elif debug:
+        ext += 'd'
+        depext += 'd'
+
+    configdir = os.path.join(libdir, 'msw' + ext)
+    
+    monolithic = False 
+    cfg_file = os.path.join(configdir, 'build.cfg')
+    if os.path.exists(cfg_file):
+        cfg = parse_build_cfg(cfg_file)
+        if "MONOLITHIC" in cfg:
+            monolithic = cfg["MONOLITHIC"]
+    libpaths.append(libdir)
+    includes.append(configdir)
+    
+    def get_wxlib_name(name):
+        if name == 'base':
+            return 'wxbase%s%s' % (version_str_nodot, ext)
+        
+        return "wxmsw%s%s_%s" % (version_str_nodot, ext, name)
+    
+    libs.extend(['wxzlib' + depext, 'wxjpeg' + depext, 'wxpng' + depext, 'wxexpat' + depext])
+    if monolithic:
+        libs.extend(["wxmsw%s%s" % (version_str_nodot, ext)])
+    else:
+        libs.extend([get_wxlib_name('base'), get_wxlib_name('core')])
+    
+    if wxPython or debug:
+        defines.append('__WXDEBUG__')
+        
+    return (defines, includes, libs, libpaths)
